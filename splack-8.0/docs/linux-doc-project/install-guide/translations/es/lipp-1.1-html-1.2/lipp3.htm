<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Lipp3</TITLE>
<META NAME="Versión" CONTENT="8.0.3514">
<META NAME="Fecha" CONTENT="05/12/96">
<META NAME="Template" CONTENT="C:\ARCHIVOS DE PROGRAMA\MICROSOFT OFFICE\OFFICE\html.dot">
<STYLE type="text/css"><!--         
A:LINK {COLOR:BLUE; TEXT-DECORATION:NONE}
A:VISITED {COLOR:GREY; TEXT-DECORATION:NONE}
A:HOVER {COLOR:RED; TEXT-DECORATION:UNDERLINE}
--></STYLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" VLINK="#800080" BGCOLOR="#FFFFFF">
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=4 WIDTH=737>
  <TR> 
    <TD WIDTH="46%" VALIGN="TOP"> 
      <P><A HREF="lipp2.htm"><IMG SRC="left.gif" BORDER=0 WIDTH=36 HEIGHT=34></A> 
    </TD>
    <TD WIDTH="11%" VALIGN="TOP"> 
      <P ALIGN="CENTER"><A HREF="lipp.htm"><IMG SRC="up.gif" BORDER=0 WIDTH=34 HEIGHT=36></A> 
    </TD>
    <TD WIDTH="43%" VALIGN="TOP"> 
      <P ALIGN="RIGHT"><A HREF="lipp4.htm"><IMG SRC="right.gif" BORDER=0 WIDTH=36 HEIGHT=34></A> 
    </TD>
  </TR>
</TABLE>
<P>&nbsp;</P>
<P ALIGN="CENTER"><font color="#000000" size="2"><b><u><font size="6">Cap&iacute;tulo 
  3</font></u></b></font></P>
<P> 
<HR>
<p><b><u><font size="3"><a href="#tutorial">Tutorial de Linux</a></font></u></b></font></p>
<dir> 
   <dir> 
    <p><font color="#000000" size="2"><a name="indice"></a><a href="#3.1">3.1 
      Introducci&oacute;n</a></font></p>
    <p><font color="#000000" size="2"><a href="#3.2">3.2 Conceptos b&aacute;sicos 
      de UNIX</a></font></p>
    <dir> 
      <dir> <font color="#000000" size="2"><a href="#3.2.1">3.2.1 Creaci&oacute;n 
        de una cuenta</a><br>
        <a href="#3.2.2">3.2.2 Presentaci&oacute;n en el sistema (loggin in)</a><br>
        <a href="#3.2.3">3.2.3 Consolas virtuales</a><br>
        <a href="#3.2.4">3.2.4 Interpretes de comandos y comandos</a><br>
        <a href="#3.2.5">3.2.5 Salida del sistema</a><br>
        <a href="#3.2.6">3.2.6 Cambiando la palabra de paso</a><br>
        <a href="#3.2.7">3.2.7 Ficheros y directorios</a><br>
        <a href="#3.2.8">3.2.8 El &aacute;rbol de directorios</a><br>
        <a href="#3.2.9">3.2.9 Directorio de trabajo actual</a><br>
        <a href="#3.2.10">3.2.10 Refiri&eacute;ndose al directorio home</a></font></dir>
    </dir>
    <p><font color="#000000" size="2"><a href="#3.3">3.3 Primeros pasos en UNIX</a></font></p>
    <dir> 
      <dir> 
        <p><font color="#000000" size="2"><a href="#3.3.1">3.3.1 Movi&eacute;ndonos 
          por el entorno</a><br>
          <a href="#3.3.2">3.3.2 Mirando el contenido de los directorios</a><br>
          <a href="#3.3.3">3.3.3 Creando directorios nuevos</a><br>
          <a href="#3.3.4">3.3.4 Copia de ficheros</a><br>
          <a href="#3.3.5">3.3.5 Moviendo ficheros</a><br>
          <a href="#3.3.6">3.3.6 Borrando ficheros y directorios</a><br>
          <a href="#3.3.7">3.3.7 Mirando los ficheros </a><br>
          <a href="#3.3.8">3.3.8 Obteniendo ayuda en l&iacute;nea</a></font></p>
      </dir>
    </dir>
    <p><font color="#000000" size="2"><a href="#3.4">3.4 Sumario de Ordenes B&aacute;sicas</a></font></p>
    <p><font color="#000000" size="2"><a href="#3.5">3.5 Explorando el Sistema 
      de Ficheros</a><br>
      <a href="#3.6">3.6 Tipos de interpretes de comandos</a><br>
      <a href="#3.7">3.7 Caracteres comod&iacute;n</a><br>
      <a href="#3.8">3.8 Fontaner&iacute;a UNIX</a></font></p>
    <dir> 
      <dir> 
        <p><font color="#000000" size="2"><a href="#3.8.1">3.8.1 Entrada y salida 
          est&aacute;ndard</a><br>
          <a href="#3.8.2">3.8.2 Redireccionando la entrada y salida</a><br>
          <a href="#3.8.3">3.8.3 Uso de tuber&iacute;as (pipes)</a><br>
          <a href="#3.8.4">3.8.4 Redirecci&oacute;n no destructiva</a></font></p>
      </dir>
    </dir>
    <p><font color="#000000" size="2"><a href="#3.9">3.9 Permisos de Ficheros</a></font></p>
    <dir> 
      <dir> 
        <p><font color="#000000" size="2"><a href="#3.9.1">3.9.1 Conceptos de 
          permisos de ficheros</a><br>
          <a href="#3.9.2">3.9.2 Interpretando los permisos de ficheros</a><br>
          <a href="#3.9.3">3.9.3 Dependencias</a><br>
          <a href="#3.9.4">3.9.4 Cambiando permisos</a></font></p>
      </dir>
    </dir>
    <p><font color="#000000" size="2"><a href="#3.10">3.10 Manejando enlaces de 
      ficheros</a></font></p>
    <dir> 
      <dir> 
        <p><font color="#000000" size="2"><a href="#3.10.1">3.10.1 Enlaces duros 
          (Hard links)</a><br>
          <a href="#3.10.2">3.10.2 Enlaces simb&oacute;licos</a></font></p>
      </dir>
    </dir>
    <p><font color="#000000" size="2"><a href="#3.11">3.11 Control de Tareas</a></font></p>
    <dir> 
      <dir> 
        <p><font color="#000000" size="2"><a href="#3.11.1">3.11.1 Tareas y procesos</a><br>
          <a href="#3.11.2">3.11.2 Primer plano y Segundo plano</a><br>
          <a href="#3.11.3">3.11.3 Env&iacute;o a segundo plano y eliminaci&oacute;n 
          de procesos</a><br>
          3.11.4 Parada y relanzamiento de tareas</font></p>
      </dir>
    </dir>
    <p><font color="#000000" size="2"><a href="#3.12">3.12 Usando el editor vi</a></font></p>
    <dir> 
      <dir> 
        <p><font color="#000000" size="2"><a href="#3.12.1">3.12.1 Conceptos</a><br>
          <a href="#3.12.2">3.12.2 Comenzando con vi</a><br>
          <a href="#3.12.3">3.12.3 Insertando texto</a><br>
          <a href="#3.12.4">3.12.4 Borrando texto</a><br>
          <a href="#3.12.5">3.12.5 Modificando texto</a><br>
          <a href="#3.12.6">3.12.6 Ordenes de movimiento</a><br>
          <a href="#3.12.7">3.12.7 Guardando ficheros y saliendo de vi</a><br>
          <a href="#3.12.8">3.12.8 Editando otro fichero</a><br>
          <a href="#3.12.9">3.12.9 Incluyendo otros ficheros</a><br>
          <a href="#3.12.10">3.12.10 Ejecutando comandos del interprete</a><br>
          <a href="#3.12.11">3.12.11 Obteniendo ayuda</a></font></p>
      </dir>
    </dir>
    <p><font color="#000000" size="2"><a href="#3.13">3.13 Personalizando su entorno</a></font></p>
    <dir> 
      <dir> 
        <p><font color="#000000" size="2"><a href="#3.13.1">3.13.1 Guiones del 
          interprete de comandos</a><br>
          <a href="#3.13.2">3.13.2 Variables del interprete de comandos y el entorno</a><br>
          <a href="#3.13.3">3.13.3 Guiones de inicializaci&oacute;n del interprete</a></font></p>
      </dir>
    </dir>
    <p><font color="#000000" size="2"><a href="#3.14">3.14 ¿Quieres seguir por 
      tu cuenta?</a></font></p>
  </dir>
</dir>
<P><a name="#tutorial"></a><font size="4" color="#000000"><b><u><font size="3">Tutorial de Linux</font></u></b></font></P>
<P><font color="#000000" size="2"><b><u><a name="3.1"></a><font size="3">3.1 Introducci&oacute;n<br>
  </font></u></b><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2">Anterior- 
  <a href="#3.2">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font><font size="3"></font></u><b><u><font size="3"><br>
  </font></u></b></font></P>
<P><font color="#000000" size="2">Los nuevos usuarios de UNIX y Linux pueden estar 
  un poco intimidados por el tama&ntilde;o y aparente complejidad del sistema 
  que tienen ante s&iacute;. Hay muchos buenos libros sobre el uso de UNIX para 
  todos los niveles, desde novatos a expertos. Pero ninguno de estos libros cubre 
  espec&iacute;ficamente una introducci&oacute;n al uso de Linux. Mientras el 
  95% del uso de Linux es exactamente como cualquier otro UNIX, la forma mas clara 
  de comenzar con su nuevo sistema es un tutorial a medida para Linux.<br>
  </font><font color="#000000" size="2">He aqu&iacute; ese tutorial.<br>
  </font><font color="#000000" size="2">Este capitulo no presentara gran cantidad 
  de detalles o cubrir&aacute; temas muy avanzados. Si no que esta pensado para 
  permitir al nuevo usuario de Linux comenzar a usar el sistema y situarlo en 
  una posici&oacute;n en la que el o ella puedan leer libros mas generales sobre 
  UNIX y entender las diferencias b&aacute;sicas entre otros sistemas UNIX y Linux.<br>
  </font><font color="#000000" size="2">Se va a presuponer muy poco, excepto quiz&aacute; 
  alguna familiaridad con los ordenadores personales y MS-DOS. Pero incluso si 
  no es un usuario de MS-DOS, deber&iacute;a ser capaz de entender cualquier cosa 
  de las que hablemos. A primera vista, UNIX parece como MS-DOS (despu&eacute;s 
  de todo, partes de MS-DOS fueron tomadas de CP/M, el cual fue a su vez inspirado 
  en UNIX). Pero, solo las caracter&iacute;sticas superficiales de UNIX se parecen 
  a MS-DOS. Incluso si es completamente nuevo en el mundo de los PC, este tutorial 
  deber&iacute;a serle de ayuda.<br>
  </font><font color="#000000" size="2">Y, antes de comenzar: No tenga miedo de 
  experimentar. El sistema no le morder&aacute;. No puede destruir nada trabajando 
  con el sistema. UNIX tiene ciertos sistemas de seguridad para evitar que usuarios 
  'normales' (del tipo que suponemos que es usted) da&ntilde;en ficheros esenciales 
  para el sistema. Incluso si ocurre el peor de los casos que es que borre todos 
  sus ficheros, tendr&aacute; que volver atr&aacute;s y reinstalar el sistema, 
  pero incluso en ese caso, no hay nada que perder.</font></P>
<P><font color="#000000" size="2"><b><u><a name="3.2"></a><font size="3">3.2 Conceptos 
  b&aacute;sicos de UNIX<br>
  </font></u></b><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.1">Anterior</a>- 
  <a href="#3.2.1">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"><br>
  </font></u></b></font></P>
<P><font color="#000000" size="2">UNIX es un sistema operativo multitarea y multiusuario. 
  Esto significa que puede haber mas de una persona usando un ordenador a la vez, 
  cada uno de ellos ejecutando a su vez diferentes aplicaciones.<br>
  </font><font color="#000000" size="2">(Esto difiere de MS-DOS, donde solo una 
  persona puede usar el sistema en un momento dado). Bajo UNIX, para que los usuarios 
  puedan identificarse en el sistema, deben presentarse (log in), proceso que 
  consta de dos pasos: Introducir el nombre de usuario (login) (el nombre con 
  que ser&aacute; identificado por el sistema), y una palabra de paso (password), 
  la cual es su llave personal secreta para entrar en la cuenta. Como solo usted 
  conoce su palabra de paso, nadie mas podr&aacute; presentarse en el sistema 
  con su nombre de usuario.<br>
  </font><font color="#000000" size="2">En los sistemas UNIX tradicionales, el 
  administrador del sistema asignara el nombre de usuario y una palabra de paso 
  inicial en el momento de crear la cuenta de usuario. Como usted es el administrador 
  del sistema, debe configurar su propia cuenta antes de poder presentarse. Ver 
  Secci&oacute;n 3.2.1 mas adelante. Para el resto de las discusiones, usaremos 
  el nombre de usuario "larry".<br>
  </font><font color="#000000" size="2">Adem&aacute;s, cada sistema UNIX tiene 
  un nombre del sistema (hostname) asignado. Este "hostname" le da nombre a la 
  maquina, adem&aacute;s de car&aacute;cter y encanto. El nombre del sistema es 
  usado para identificar maquinas en una red, pero incluso aunque la maquina no 
  este en red, deber&iacute;a tener su nombre. En la Secci&oacute;n 4.10.2 veremos 
  como inicializar el nombre de la maquina. En nuestros ejemplos, el nombre del 
  sistema ser&aacute; "mousehouse"</font></P>
<P><font color="#000000" size="2"><u><a name="3.2.1"></a>3.2.1 Creaci&oacute;n 
  de una cuenta<br>
  <font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.2">Anterior</a>- 
  <a href="#3.2.2">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"></font></u></b><u><br>
  </u></font></P>
<P><font color="#000000" size="2">Antes de poder usar el sistema, deber&aacute; 
  configurarse una cuenta de usuario. Esto es necesario, porque no es buena idea 
  usar la cuenta de root para los usos normales. La cuenta de root deber&iacute;a 
  reservarse para el uso de comandos privilegiados y para el mantenimiento del 
  sistema, como se vera en la Secci&oacute;n 4.1.<br>
  </font><font color="#000000" size="2">Para crear su propia cuenta, necesita 
  entrar en la cuenta de root y usar las &oacute;rdenes useradd o adduser. Ver 
  la Secci&oacute;n 4.4 para informaci&oacute;n sobre este procedimiento.</font></P>
<P><font color="#000000" size="2"><u><a name="3.2.2"></a>3.2.2 Presentaci&oacute;n 
  en el sistema (loggin in)<br>
  <font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.2.1">Anterior</a>- 
  <a href="#3.2.3">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"></font></u></b><u><br>
  </u></font></P>
<P><font color="#000000" size="2">En el momento de presentarse en el sistema, 
  vera la siguiente l&iacute;nea de comandos en la pantalla:</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">mousehouse login:</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2"> Ahora, introduzca su nombre de usuario y pulse 
  |_Return_|. Nuestro h&eacute;roe larry, teclear&iacute;a lo siguiente:</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">mousehouse login: larry<br>
      </font><font color="#000000" size="2">Password:</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Ahora introduzca la palabra de paso. Esta no 
  ser&aacute; mostrada en la pantalla conforme se va tecleando, por lo que debe 
  teclear cuidadosamente. Si introduce una palabra de paso incorrecta, se mostrar&aacute; 
  el siguiente mensaje</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">Login incorrect</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">y deber&aacute; intentarlo de nuevo.<br>
  </font><font color="#000000" size="2">Una vez que ha introducido correctamente 
  el nombre de usuario y la palabra de paso, est&aacute; oficialmente "presentado" 
  en el sistema y libre para comenzar a trabajar.</font></P>
<P><font color="#000000" size="2"><u><a name="3.2.3"></a>3.2.3 Consolas virtuales<br>
  <font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.2.2">Anterior</a>- 
  <a href="#3.2.4">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"></font></u></b><u></u><u><br>
  </u></font></P>
<P><font color="#000000" size="2">La consola del sistema es el monitor y teclado 
  conectado directamente al sistema. (Como UNIX es un sistema operativo multiusuario, 
  puede tener otros terminales conectados a puertos serie del sistema, pero estos 
  no ser&aacute;n la consola). Linux, como otras versiones de UNIX, proporciona 
  acceso a consolas virtuales (o VC's), las cuales le permitir&aacute;n tener 
  mas de una sesi&oacute;n de trabajo activa desde la consola a la vez.<br>
  </font><font color="#000000" size="2">Para demostrar esto, entre en su sistema 
  (como hemos visto antes). Ahora pulse |_alt-F2_|<br>
  </font><font color="#000000" size="2">Deber&iacute;a ver la pregunta login: 
  de nuevo. Esta viendo la segunda consola virtual ha entrado en el sistema por 
  la primera. Para volver a la primera VC, pulse |_alt-F1_|. Voila! ha vuelto 
  a la primera sesi&oacute;n.<br>
  </font><font color="#000000" size="2">Un sistema Linux reci&eacute;n instalado 
  probablemente le permita acceder a las primeras cuatro VC's, usando |_alt-F1_| 
  a |_alt-F4_|. Pero es posible habilitar hasta 12 VC's una por cada tecla de 
  funci&oacute;n del teclado. Como puede ver, el uso de VC's es muy potente puede 
  estar trabajando en diferentes VC's a la vez.<br>
  </font><font color="#000000" size="2">Mientras que el uso de VC's es algo limitado 
  (despu&eacute;s de todo, solo puede mirar un VC cada vez), esto deber&iacute;a 
  darle una idea de las capacidades multiusuario del sistema. Mientras esta trabajando 
  en el VC #1, puede conmutar al VC #2 y comenzar a trabajar en otra cosa.</font></P>
<P><font color="#000000" size="2"><u><a name="3.2.4"></a>3.2.4 Interpretes de 
  comandos y comandos<br>
  <font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.2.3">Anterior</a>- 
  <a href="#3.2.5">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"></font></u></b><u></u><u><br>
  </u></font></P>
<P><font color="#000000" size="2">En la mayor&iacute;a de las exploraciones en 
  el mundo de UNIX, estar&aacute; hablando con el sistema a trav&eacute;s del 
  uso de un int&eacute;rprete de comandos. Un int&eacute;rprete de comandos es 
  simplemente un programa que toma la entrada del usuario (p.e. las &oacute;rdenes 
  que teclea) y las traduce a instrucciones. Esto puede ser comparado con el COMMAND.COM 
  de MS-DOS, el cual efect&uacute;a esencialmente la misma tarea. El int&eacute;rprete 
  de comandos es solo uno de los interfaces con UNIX. Hay muchos interfaces posibles, 
  como el sistema X Windows, el cual le permite ejecutar comandos usando el rat&oacute;n 
  y el teclado.<br>
  </font><font color="#000000" size="2">Tan pronto como entra en 
  el sistema, el sistema arranca un int&eacute;rprete de comandos y Ud. ya puede 
  teclear &oacute;rdenes al sistema. Veamos un ejemplo r&aacute;pido. Aqu&iacute;, 
  Larry entra en el sistema y es situado en el int&eacute;rprete de comandos</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">mousehouse login: larry<br>
      </font><font color="#000000" size="2">Password: larry's password<br>
      </font><font color="#000000" size="2">Welcome to Mousehouse!<br>
      </font><font color="#000000" size="2">/home/larry#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2"> "/home/larry#" es el "prompt" del int&eacute;rprete 
  de comandos, indicando que esta listo para recibir &oacute;rdenes. Tratemos 
  de decirle al sistema que haga algo interesante:</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# make love<br>
      </font><font color="#000000" size="2">make: *** No way to make target `love'. 
      Stop.<br>
      </font><font color="#000000" size="2">/home/larry#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Bien, como resulta que make es el nombre de 
  un programa ya existente en el sistema, el int&eacute;rprete de comandos lo 
  ejecuta. (Desafortunadamente, el sistema no esta siendo muy amigable).<br>
  </font><font color="#000000" size="2">Esto 
  nos lleva a una cuesti&oacute;n importante: ¿Que son &oacute;rdenes? ¿Que ocurre 
  cuando tecleamos "make love"? La primera palabra de la orden, "make", es el 
  nombre de la orden a ejecutar. El resto de la orden es tomado como argumentos 
  de la orden. Ejemplos:</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# cp foo bar</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Aqu&iacute;, el nombre de la orden es "cp", 
  y los argumentos son "foo" y "bar".<br>
  </font><font color="#000000" size="2">Cuando teclea una orden, el int&eacute;rprete 
  de comandos hace varias cosas. Primero de todo, busca el nombre de la orden 
  y comprueba si es una orden interna. (Es decir, una orden que el propio int&eacute;rprete 
  de comandos sabe ejecutar por si mismo. Hay bastantes &oacute;rdenes de ese 
  tipo que veremos mas adelante). El int&eacute;rprete de comandos tambi&eacute;n 
  comprueba si la orden es un "alias" o nombre sustitutorio de otra orden. Si 
  no se cumple ninguno de estos casos, el int&eacute;rprete de comandos busca 
  el programa y lo ejecuta pas&aacute;ndole los argumentos especificados en la 
  l&iacute;nea de comandos.<br>
  </font><font color="#000000" size="2">En nuestro ejemplo, el int&eacute;rprete 
  de comandos busca el programa llamado make y lo ejecuta con el argumento love. 
  make es un programa usado a menudo para compilar programas grandes, y toma como 
  argumentos el nombre de un "objetivo" a compilar. En el caso de "make love", 
  ordenamos a make que compile el objetivo love. Como make no puede encontrar 
  un objetivo de ese nombre, falla enviando un mensaje de error y volviendo al 
  int&eacute;rprete de comandos.<br>
  </font><font color="#000000" size="2">¿Que ocurre 
  si tecleamos una orden y el int&eacute;rprete de comandos no puede encontrar 
  el programa de ese nombre? Bien, prob&eacute;moslo:</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# eat dirt<br>
      </font><font color="#000000" size="2">eat: command not found<br>
      </font><font color="#000000" size="2">/home/larry#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Bastante simple, si no se puede encontrar el 
  programa con el nombre dado en la orden (aqu&iacute; "eat"), se muestra un mensaje 
  de error que deber&iacute;a de ser autoexplicativo. A menudo vera este mensaje 
  de error si se equivoca al teclear una orden (por ejemplo, si hubiese tecleado 
  "mkae love" en lugar de "make love".</font></P>
<P><font color="#000000" size="2"><u><a name="3.2.5"></a>3.2.5 Salida del sistema<br>
  <font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.2.4">Anterior</a>- 
  <a href="#3.2.6">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"></font></u></b><u></u><u><br>
  </u></font></P>
<P><font color="#000000" size="2">Antes de ahondar mas, deber&iacute;amos ver 
  como salir del sistema. Desde la l&iacute;nea de &oacute;rdenes usaremos la 
  orden</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# exit</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">para salir. Hay otras formas, pero esta es la 
  mas f&aacute;cil.</font></P>
<P><font color="#000000" size="2"><u><a name="3.2.6"></a>3.2.6 Cambiando la palabra 
  de paso<br>
  <font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.2.5">Anterior</a>- 
  <a href="#3.2.7">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"></font></u></b><u></u><u><br>
  </u></font></P>
<P><font color="#000000" size="2">Tambi&eacute;n debe asegurarse de la forma de 
  cambiar su palabra de paso. La orden passwd le pedir&aacute; su palabra de paso 
  vieja y la nueva. Volver&aacute; a pedir una segunda vez la nueva para validarla. 
  Tenga cuidado de no olvidar su palabra de paso, si eso ocurre, deber&aacute; 
  pedirle al administrador del sistema que la modifique por usted. (Si es el administrador 
  del sistema, vea la Secci&oacute;n 4.4.)</font></P>
<P><font color="#000000" size="2"><u><a name="3.2.7"></a>3.2.7 Ficheros y directorios<br>
  <font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.2.6">Anterior</a>- 
  <a href="#3.2.8">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"></font></u></b><u></u><u><br>
  </u></font></P>
<P><font color="#000000" size="2">Bajo la mayor&iacute;a de los sistemas operativos 
  (UNIX incluido), existe el concepto de fichero, el cual es un conjunto de informaci&oacute;n 
  al que se le ha asignado un nombre (llamado nombre del fichero).<br>
  </font><font color="#000000" size="2">Ejemplos de fichero son un mensaje de 
  correo, o un programa que puede ser ejecutado. Esencialmente, cualquier cosa 
  salvada en el disco es guardada en un fichero individual.<br>
  </font><font color="#000000" size="2">Los ficheros son identificados por sus 
  nombres. Por ejemplo, el fichero que contiene su historial podr&iacute;a ser 
  salvado con el nombre history-paper. Estos nombres usualmente identifican el 
  fichero y su contenido de alguna forma significativa para usted. No hay un formato 
  est&aacute;ndar para los nombres de los ficheros como lo hay en MS-DOS y en 
  otros sistemas operativos; en general estos pueden contener cualquier car&aacute;cter 
  (excepto / _ ver la discusi&oacute;n sobre "pathnames" (rutas de ficheros) mas 
  adelante), y est&aacute;n limitados a 256 caracteres de longitud.<br>
  </font><font color="#000000" size="2">Con el concepto de fichero aparece el 
  concepto de directorio. Un directorio es simplemente una colecci&oacute;n de 
  ficheros. Puede ser considerado como una "carpeta" que contiene muchos ficheros 
  diferentes. Los directorios tambi&eacute;n tienen nombre con el que los podemos 
  identificar. Adem&aacute;s, los directorios mantienen una estructura de &aacute;rbol; 
  es decir, directorios pueden contener otros directorios.<br>
  </font><font color="#000000" size="2">Un 
  fichero puede ser referenciado por su nombre con camino, el cual esta constituido 
  por su nombre, antecedido por el nombre del directorio que lo contiene. Por 
  ejemplo, supongamos que Larry tiene un directorio de nombre papers que contiene 
  tres ficheros: history-final, english-lit y masters-thesis. (Cada uno de los 
  tres ficheros contiene informaci&oacute;n sobre tres de los proyectos en los 
  que Larry esta trabajando). Para referirse al fichero english-lit, Larry puede 
  especificar su camino:</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">papers/english-lit</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Como puede ver, el directorio y el nombre del 
  fichero van separados por un car&aacute;cter /. Por esta raz&oacute;n, los nombres 
  de fichero no pueden contener este car&aacute;cter. Los usuarios de MS-DOS encontraran 
  esta convenci&oacute;n familiar, aunque en el mundo MS-DOS se usa el car&aacute;cter 
  \).<br>
  </font><font color="#000000" size="2">Como hemos mencionado, los directorios 
  pueden anidarse uno dentro de otro. Por ejemplo, supongamos que Larry tiene 
  otro directorio dentro de papers llamado cheat-sheet. El camino de este fichero 
  seria &nbsp;</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">papers/notes/cheat-sheet</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Por lo tanto, el camino realmente es la "ruta" 
  que se debe tomar para localizar a un fichero. El directorio sobre un subdirectorio 
  dado es conocido como el directorio padre. Aqu&iacute;, el directorio papers 
  es el padre del directorio notes.</font></P>
<P><font color="#000000" size="2"><u><a name="3.2.8"></a>3.2.8 El &aacute;rbol 
  de directorios<br>
  <font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.2.7">Anterior</a>- 
  <a href="#3.2.9">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"></font></u></b><u></u><u><br>
  </u></font></P>
<P><font color="#000000" size="2">La mayor&iacute;a de los sistemas UNIX tienen 
  una distribuci&oacute;n de ficheros est&aacute;ndar, de forma que recursos y 
  ficheros puedan ser f&aacute;cilmente localizados. Esta distribuci&oacute;n 
  forma el &aacute;rbol de directorios, el cual comienza en el directorio "/", 
  tambi&eacute;n conocido como "directorio ra&iacute;z". Directamente por debajo 
  de / hay algunos subdirectorios importantes: /bin, /etc, /dev y /usr, entre 
  otros. Estos a su vez contienen otros directorios con ficheros de configuraci&oacute;n 
  del sistema, programas, etc.<br>
  </font><font color="#000000" size="2">En particular, cada usuario tiene un directorio 
  "home". Este es el directorio en el que el usuario guardara sus ficheros. En 
  los ejemplos anteriores, todos los ficheros de Larry (como cheat-sheer y history-final) 
  estaban contenidos en el directorio home de Larry. Usualmente, los directorios 
  home de los usuarios cuelgan de /home y son nombrados con el nombre del usuario 
  al que pertenecen.<br>
  </font><font color="#000000" size="2">Por lo tanto, el directorio "home" de 
  Larry es /home/larry.<br>
  </font><font color="#000000" size="2">En la figura 3.1 se muestra un &aacute;rbol 
  de directorio de ejemplo. Este deber&iacute;a darle una idea de como esta organizado 
  en su sistema el &aacute;rbol de directorios.</font></P>
<P><font color="#000000" size="2"><u><a name="3.2.9"></a>3.2.9 Directorio de trabajo 
  actual<br>
  <font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.2.8">Anterior</a>- 
  <a href="#3.2.10">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"></font></u></b><u></u><u><br>
  </u></font></P>
<P><font color="#000000" size="2">En cualquier momento, las &oacute;rdenes que 
  teclee al int&eacute;rprete de comandos son dadas en t&eacute;rminos de su directorio 
  de trabajo actual. Puede pensar en su directorio actual de trabajo como en el 
  directorio en el que actualmente esta "situado". Cuando entra en el sistema, 
  su directorio de trabajo se inicializa a su directorio home_/home/larry en nuestro 
  caso. En cualquier momento que referencie a un fichero, puede hacerlo en relaci&oacute;n 
  a su directorio de trabajo actual, en lugar de especificar el camino completo 
  del fichero.<br>
  </font><font color="#000000" size="2">Vemos un ejemplo. Larry tiene 
  el directorio papers, y papers contiene el fichero history-final. Si Larry quiere 
  echar un vistazo a ese fichero, puede usar la orden</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# more /home/larry/papers/history-final</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">La orden more simplemente muestra el fichero, 
  pantalla a pantalla. Pero, como el directorio de trabajo actual de Larry es 
  /home/larry, podr&iacute;a haberse referido al fichero de forma relativa a su 
  directorio de trabajo actual. La orden seria</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# more papers/history-final</font></P>
  </DIR>
</DIR>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=4 WIDTH=334>
  <TR> 
    <TD WIDTH="13%" VALIGN="TOP"> 
      <P><font size="2" color="#000000">/___</font> 
    </TD>
    <TD WIDTH="25%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">bin </font> 
    </TD>
    <TD WIDTH="30%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
    <TD WIDTH="32%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
  </TR>
  <TR> 
    <TD WIDTH="13%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">|___ </font> 
    </TD>
    <TD WIDTH="25%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">dev </font> 
    </TD>
    <TD WIDTH="30%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
    <TD WIDTH="32%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
  </TR>
  <TR> 
    <TD WIDTH="13%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">|___ </font> 
    </TD>
    <TD WIDTH="25%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">etc </font> 
    </TD>
    <TD WIDTH="30%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
    <TD WIDTH="32%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
  </TR>
  <TR> 
    <TD WIDTH="13%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">|___ </font> 
    </TD>
    <TD WIDTH="25%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">home_____ </font> 
    </TD>
    <TD WIDTH="30%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">larry </font> 
    </TD>
    <TD WIDTH="32%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
  </TR>
  <TR> 
    <TD WIDTH="13%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">| </font> 
    </TD>
    <TD WIDTH="25%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">|________ </font> 
    </TD>
    <TD WIDTH="30%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">sam </font> 
    </TD>
    <TD WIDTH="32%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
  </TR>
  <TR> 
    <TD WIDTH="13%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">|___ </font> 
    </TD>
    <TD WIDTH="25%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">lib </font> 
    </TD>
    <TD WIDTH="30%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
    <TD WIDTH="32%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
  </TR>
  <TR> 
    <TD WIDTH="13%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">|___ </font> 
    </TD>
    <TD WIDTH="25%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">proc </font> 
    </TD>
    <TD WIDTH="30%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
    <TD WIDTH="32%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
  </TR>
  <TR> 
    <TD WIDTH="13%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">|___ </font> 
    </TD>
    <TD WIDTH="25%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">tmp </font> 
    </TD>
    <TD WIDTH="30%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
    <TD WIDTH="32%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
  </TR>
  <TR> 
    <TD WIDTH="13%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">|___ </font> 
    </TD>
    <TD WIDTH="25%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">usr______ </font> 
    </TD>
    <TD WIDTH="30%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">X386 </font> 
    </TD>
    <TD WIDTH="32%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
  </TR>
  <TR> 
    <TD WIDTH="13%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
    <TD WIDTH="25%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">|________ </font> 
    </TD>
    <TD WIDTH="30%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">bin </font> 
    </TD>
    <TD WIDTH="32%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
  </TR>
  <TR> 
    <TD WIDTH="13%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
    <TD WIDTH="25%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">|________ </font> 
    </TD>
    <TD WIDTH="30%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">emacs </font> 
    </TD>
    <TD WIDTH="32%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
  </TR>
  <TR> 
    <TD WIDTH="13%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
    <TD WIDTH="25%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">|________ </font> 
    </TD>
    <TD WIDTH="30%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">etc </font> 
    </TD>
    <TD WIDTH="32%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
  </TR>
  <TR> 
    <TD WIDTH="13%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
    <TD WIDTH="25%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">|________ </font> 
    </TD>
    <TD WIDTH="30%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">g++-include </font> 
    </TD>
    <TD WIDTH="32%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
  </TR>
  <TR> 
    <TD WIDTH="13%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
    <TD WIDTH="25%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">|________ </font> 
    </TD>
    <TD WIDTH="30%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">include </font> 
    </TD>
    <TD WIDTH="32%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
  </TR>
  <TR> 
    <TD WIDTH="13%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
    <TD WIDTH="25%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">|________ </font> 
    </TD>
    <TD WIDTH="30%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">lib </font> 
    </TD>
    <TD WIDTH="32%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
  </TR>
  <TR> 
    <TD WIDTH="13%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
    <TD WIDTH="25%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">|________ </font> 
    </TD>
    <TD WIDTH="30%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">local______ </font> 
    </TD>
    <TD WIDTH="32%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">bin </font> 
    </TD>
  </TR>
  <TR> 
    <TD WIDTH="13%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
    <TD WIDTH="25%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">| </font> 
    </TD>
    <TD WIDTH="30%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">|__________ </font> 
    </TD>
    <TD WIDTH="32%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">emacs </font> 
    </TD>
  </TR>
  <TR> 
    <TD WIDTH="13%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
    <TD WIDTH="25%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">| </font> 
    </TD>
    <TD WIDTH="30%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">|__________ </font> 
    </TD>
    <TD WIDTH="32%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">etc </font> 
    </TD>
  </TR>
  <TR> 
    <TD WIDTH="13%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
    <TD WIDTH="25%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">| </font> 
    </TD>
    <TD WIDTH="30%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">|__________ </font> 
    </TD>
    <TD WIDTH="32%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">lib </font> 
    </TD>
  </TR>
  <TR> 
    <TD WIDTH="13%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
    <TD WIDTH="25%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">|________ </font> 
    </TD>
    <TD WIDTH="30%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">man </font> 
    </TD>
    <TD WIDTH="32%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
  </TR>
  <TR> 
    <TD WIDTH="13%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
    <TD WIDTH="25%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">|________ </font> 
    </TD>
    <TD WIDTH="30%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">spool </font> 
    </TD>
    <TD WIDTH="32%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
  </TR>
  <TR> 
    <TD WIDTH="13%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
    <TD WIDTH="25%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">|________ </font> 
    </TD>
    <TD WIDTH="30%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">src________ </font> 
    </TD>
    <TD WIDTH="32%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">linux </font> 
    </TD>
  </TR>
  <TR> 
    <TD WIDTH="13%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
    <TD WIDTH="25%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">|________ </font> 
    </TD>
    <TD WIDTH="30%" VALIGN="TOP"> 
      <P><font color="#000000" size="2">tmp </font> 
    </TD>
    <TD WIDTH="32%" VALIGN="TOP"> 
      <P>&nbsp; 
    </TD>
  </TR>
</TABLE>
<P><font color="#000000" size="2">Figura 3.1: T&iacute;pico &aacute;rbol de directorios 
  Unix (resumido).</font></P>
<P><font color="#000000" size="2">Por lo tanto, si comienza el nombre de un fichero 
  (como papers/final) con un car&aacute;cter distinto a "/", el sistema supone 
  que se esta refiriendo al fichero con su posici&oacute;n relativa a su directorio 
  de trabajo. Esto es conocido como camino relativo.<br>
  </font><font color="#000000" size="2">Por otra parte, si comienza el nombre 
  del fichero con "/", el sistema interpreta esto como un camino completo, es 
  decir, el camino al fichero completo desde el directorio ra&iacute;z, /. Esto 
  es conocido como camino absoluto.</font></P>
<P><font color="#000000" size="2"><u><a name="3.2.10"></a>3.2.10 Refiri&eacute;ndose 
  al directorio home<br>
  <font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.2.9">Anterior</a>- 
  <a href="#3.3">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"></font></u></b><u></u><u><br>
  </u></font></P>
<P><font color="#000000" size="2">Bajo tcsh y bash,1 el directorio "home" puede 
  ser referenciado usando el car&aacute;cter de la tilde ( ~ ). Por ejemplo, la 
  orden</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# more "/papers/history-final</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">es equivalente a</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# more /home/larry/papers/history-final</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">El car&aacute;cter "~" es simplemente sustituido 
  por el int&eacute;rprete de comandos, con el nombre del directorio home. Adem&aacute;s, 
  tambi&eacute;n puede especificar otros directorios home de usuarios con la tilde. 
  El camino "~karl/letters" es traducido por el int&eacute;rprete de &oacute;rdenes 
  a "/home/karl/letters" (si /home/karl es el directorio home de karl). El uso 
  de la tilde es simplemente un atajo; no existe ning&uacute;n directorio llamado 
  "~", es simplemente una ayuda sint&aacute;ctica proporcionada por el int&eacute;rprete 
  de comandos.</font></P>
<P><font color="#000000" size="2"><b><u><a name="3.3"></a><font size="3">3.3 Primeros 
  pasos en UNIX<br>
  </font></u></b><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.2.10">Anterior</a>- 
  <a href="#3.3.1">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"><br>
  </font></u></b></font></P>
<P><font color="#000000" size="2">Antes de comenzar es importante destacar que 
  todos los nombres de ficheros y comandos son "case-sensitive" (que hacen diferencia 
  entre may&uacute;sculas y min&uacute;sculas, a diferencia de sistemas operativos 
  como MS-DOS). Por ejemplo, el comando make es diferente a Make o MAKE. Lo mismo 
  ocurre en el caso de nombres de ficheros o directorios.</font></P>
<P><font color="#000000" size="2"><u><a name="3.3.1"></a>3.3.1 Movi&eacute;ndonos 
  por el entorno<br>
  <font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.3">Anterior</a>- 
  <a href="#3.3.2">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"></font></u></b><u><br>
  </u></font></P>
<P><font color="#000000" size="2">Ahora que ya podemos presentarnos como usuarios, 
  y sabemos como indicar ficheros con su camino completo, ¿como podemos cambiar 
  nuestro directorio de trabajo?<br>
  </font><font color="#000000" size="2">La orden 
  para movernos por la estructura de directorios es cd, abreviaci&oacute;n de 
  "cambio de directorio". Hay que destacar, que la mayor&iacute;a de las &oacute;rdenes 
  Unix mas usadas son de dos o tres letras. La forma de uso de la orden cd es:</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">cd &lt;directorio&gt;</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">donde &lt;directorio&gt; es el nombre del directorio 
  al que queremos ir.<br>
  </font><font color="#000000" size="2">Como dijimos, al entrar 
  al sistema comenzamos en el directorio "home". Si Larry quiere ir al subdirectorio 
  papers, deber&iacute;a usar la orden</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# cd papers<br>
      </font><font color="#000000" size="2">/home/larry/papers#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">_____________________________________________</font></P>
<P><font color="#000000" size="2">1 tcsh y bash son dos interpretes de comandos 
  que corren bajo Linux. Un int&eacute;rprete de comandos es el programa que lee 
  las &oacute;rdenes del usuario y las ejecuta; la mayor&iacute;a de los sistemas 
  Linux habilitan tcsh o bash para las nuevas cuentas de usuario.<br>
  </font><font color="#000000" size="2">Como 
  se puede ver, la l&iacute;nea de comandos de Larry cambia para mostrar su directorio 
  actual de trabajo. Ahora que ya esta en el directorio papers puede echarle un 
  vistazo a su fichero history-final con el comando</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry/papers# more history-final</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Ahora Larry esta en el subdirectorio papers, 
  para volver al directorio padre de este, usara la orden</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry/papers# cd ..<br>
      </font><font color="#000000" size="2">/home/larry#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">(D&eacute;se cuenta del espacio entre "cd" y 
  ".."). Cada directorio tiene una entrada de nombre ".." la cual se refiere al 
  directorio padre. De igual forma, existe en cada directorio la entrada "." la 
  cual se refiere a si mismo. As&iacute; que el comando</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry/papers# cd .<br>
      </font><font color="#000000" size="2">/home/larry#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">nos deja donde estamos.<br>
  </font><font color="#000000" size="2">Tambi&eacute;n 
  pueden usarse nombres con el camino absoluto en la orden cd. Para ir al directorio 
  de Karl con cd, introduciremos la siguiente orden.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry/papers# cd /home/karl<br>
      </font><font color="#000000" size="2">/home/karl#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Tambi&eacute;n, usando cd sin argumentos nos 
  llevara a nuestro directorio de origen.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/karl# cd<br>
      </font><font color="#000000" size="2">/home/larry#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2"><u><a name="3.3.2"></a>3.3.2 Mirando el contenido 
  de los directorios<br>
  <font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.3.1">Anterior</a>- 
  <a href="#3.3.3">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"></font></u></b><u></u><u><br>
  </u></font></P>
<P><font color="#000000" size="2">Ahora que ya sabe como moverse por los directorios 
  probablemente pensara: ¿Y bien? El simple movimiento por el &aacute;rbol de 
  directorios es poco &uacute;til, necesitamos un nuevo comando, ls. ls muestra 
  por el terminal la lista de ficheros y directorios, por defecto, los del directorio 
  activo. Por ejemplo;</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# ls<br>
      </font><font color="#000000" size="2">Mail<br>
      </font><font color="#000000" size="2">letters<br>
      </font><font color="#000000" size="2">papers<br>
      </font><font color="#000000" size="2">/home/larry#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Aqu&iacute; podemos ver que Larry tiene tres 
  entradas en su directorio actual: Mail, letters y papers.<br>
  </font><font color="#000000" size="2">Esto 
  no nos dice demasiado, ¿son ficheros o directorios?. Podemos usar la opci&oacute;n 
  -F de la orden ls para obtener mas informaci&oacute;n.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# ls -F<br>
      </font><font color="#000000" size="2">Mail/<br>
      </font><font color="#000000" size="2">letters/<br>
      </font><font color="#000000" size="2">papers/<br>
      </font><font color="#000000" size="2">/home/larry#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Por el car&aacute;cter / a&ntilde;adido a cada 
  nombre sabemos que las tres entradas son subdirectorios. La orden ls -F puede 
  tambi&eacute;n a&ntilde;adir al final "*", esto indica que es un fichero ejecutable. 
  Si ls -F no a&ntilde;ade nada, entonces es un fichero normal, es decir no es 
  ni un directorio ni un ejecutable.<br>
  </font><font color="#000000" size="2">Por lo general cada orden UNIX puede tomar 
  una serie de opciones definidas en forma de argumentos. Estos usualmente comienzan 
  con el car&aacute;cter "-", como vimos antes con ls -F. La opci&oacute;n -F 
  le dice a ls que de mas informaci&oacute;n sobre el tipo de ficheros, en este 
  caso a&ntilde;adiendo un / detr&aacute;s de cada nombre de un directorio.<br>
  </font><font color="#000000" size="2">Si 
  a ls le pasamos un nombre de directorio, mostrar&aacute; el contenido de ese 
  directorio.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# ls -F papers<br>
      </font><font color="#000000" size="2">english-lit<br>
      </font><font color="#000000" size="2">history-final<br>
      </font><font color="#000000" size="2">masters-thesis<br>
      </font><font color="#000000" size="2">notes/<br>
      </font><font color="#000000" size="2">/home/larry#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Para ver un listado mas interesante, veamos 
  el contenido de directorio del sistema /etc.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# ls /etc<br>
      </font><font color="#000000" size="2">Images ftpusers lpc rc.new shells<br>
      </font><font color="#000000" size="2">adm getty magic rc0.d startcons<br>
      </font><font color="#000000" size="2">bcheckrc gettydefs motd rc1.d swapoff<br>
      </font><font color="#000000" size="2">brc group mount rc2.d swapon<br>
      </font><font color="#000000" size="2">brc~ inet mtab rc3.d syslog.conf<br>
      </font><font color="#000000" size="2">csh.cshrc init mtools rc4.d syslog.pid<br>
      </font><font color="#000000" size="2">csh.login init.d pac rc5.d syslogd.reload<br>
      </font><font color="#000000" size="2">default initrunlvl passwd rmt termcap<br>
      </font><font color="#000000" size="2">disktab inittab printcap rpc umount<br>
      </font><font color="#000000" size="2">fdprm inittab.old profile rpcinfo 
      update<br>
      </font><font color="#000000" size="2">fstab issue psdatabase securetty utmp<br>
      </font><font color="#000000" size="2">ftpaccess lilo rc services wtmp<br>
      </font><font color="#000000" size="2">/home/larry#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">(Para los usuarios de MS-DOS, n&oacute;tese 
  que los nombres de los ficheros pueden ser mayores de 8 caracteres y pueden 
  contener puntos en cualquier posici&oacute;n. Incluso es posible que un fichero 
  contenga mas de un punto en su nombre.)<br>
  </font><font color="#000000" size="2">Vayamos 
  al directorio ra&iacute;z con "cd .." y desde all&iacute; vayamos al directorio 
  /usr/bin.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# cd ..<br>
      </font><font color="#000000" size="2">/home# cd ..<br>
      </font><font color="#000000" size="2">/# cd usr<br>
      </font><font color="#000000" size="2">/usr# cd bin<br>
      </font><font color="#000000" size="2">/usr/bin#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Tambi&eacute;n podemos movernos dentro de directorios 
  en multiples pasos, como en cd /usr/bin.<br>
  </font><font color="#000000" size="2">Trate de moverse por varios directorios 
  usando ls y cd. En algunos casos podr&aacute; encontrarse el desagradable mensaje 
  de error "Permission denied". Esto simplemente es debido a cuestiones de seguridad 
  del UNIX. Para poder moverse o listar un directorio debe de tener permisos para 
  poder hacerlo. Hablaremos mas sobre ello en la Secci&oacute;n 3.9.</font></P>
<P><font color="#000000" size="2"><u><a name="3.3.3"></a>3.3.3 Creando directorios 
  nuevos<br>
  <font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.3.2">Anterior</a>- 
  <a href="#3.3.4">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"></font></u></b><u></u><u><br>
  </u></font></P>
<P><font color="#000000" size="2">Es el momento de aprender a crear directorios. 
  Para ello se usa la orden mkdir. Pruebe lo siguiente:</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# mkdir foo<br>
      </font><font color="#000000" size="2">/home/larry# ls -F<br>
      </font><font color="#000000" size="2">Mail/<br>
      </font><font color="#000000" size="2">foo/<br>
      </font><font color="#000000" size="2">letters/<br>
      </font><font color="#000000" size="2">papers/<br>
      </font><font color="#000000" size="2">/home/larry# cd foo<br>
      </font><font color="#000000" size="2">/home/larry/foo# ls<br>
      </font><font color="#000000" size="2">/home/larry/foo#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">¡Enhorabuena! Acaba de crear un directorio nuevo 
  y moverse a &eacute;l. Como no hay ning&uacute;n fichero </font><font color="#000000" size="2">en 
  el directorio nuevo, veamos como copiar ficheros desde un lugar a otro.</font></P>
<P><font color="#000000" size="2"><u><a name="3.3.4"></a>3.3.4 Copia de ficheros<br>
  <font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.3.3">Anterior</a>- 
  <a href="#3.3.5">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"></font></u></b><u></u><u><br>
  </u></font></P>
<P><font color="#000000" size="2">La copia de ficheros es efectuada por la orden 
  cp:</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry/foo# cp /etc/termcap .<br>
      </font><font color="#000000" size="2">/home/larry/foo# cp /etc/shells .<br>
      </font><font color="#000000" size="2">/home/larry/foo# ls -F<br>
      </font><font color="#000000" size="2">shells termcap<br>
      </font><font color="#000000" size="2">/home/larry/foo# cp shells bells<br>
      </font><font color="#000000" size="2">/home/larry/foo# ls -F<br>
      </font><font color="#000000" size="2">bells shells termcap<br>
      </font><font color="#000000" size="2">/home/larry/foo#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">La orden cp copia los ficheros listados en la 
  l&iacute;nea de comandos al fichero o directorio pasado como &uacute;ltimo argumento. 
  N&oacute;tese como se usa el directorio "." para referirnos al directorio actual.</font></P>
<P><font color="#000000" size="2"><u><a name="3.3.5"></a>3.3.5 Moviendo ficheros<br>
  <font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.3.4">Anterior</a>- 
  <a href="#3.3.6">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"></font></u></b><u></u><u><br>
  </u></font></P>
<P><font color="#000000" size="2">La orden mv mueve ficheros en lugar de copiarlos. 
  La sintaxis es muy sencilla.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry/foo# mv termcap sells<br>
      </font><font color="#000000" size="2">/home/larry/foo# ls -F<br>
      </font><font color="#000000" size="2">bells sells shells<br>
      </font><font color="#000000" size="2">/home/larry/foo#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">N&oacute;tese como termcap ya no existe, en 
  su lugar esta el fichero sells. Esta orden puede usarse para renombrar ficheros, 
  como acabamos de hacer, pero tambi&eacute;n para mover ficheros a directorios 
  diferentes.<br>
  </font><font color="#000000" size="2">3 Nota: mv y cp sobreescribiran los ficheros 
  destino (si ya existen) sin consultar. Sea cuidadoso cuando mueva un fichero 
  a otro directorio: puede haber ya un fichero con el mismo nombre que ser&aacute; 
  sobrescrito.</font></P>
<P><font color="#000000" size="2"><u><a name="3.3.6"></a>3.3.6 Borrando ficheros 
  y directorios<br>
  <font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.3.5">Anterior</a>- 
  <a href="#3.3.7">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"></font></u></b><u></u><u><br>
  </u></font></P>
<P><font color="#000000" size="2">Para borrar un fichero, use la orden rm. ("rm" 
  viene de "remove").</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry/foo# rm bells sells<br>
      </font><font color="#000000" size="2">/home/larry/foo# ls -F<br>
      </font><font color="#000000" size="2">shells<br>
      </font><font color="#000000" size="2">/home/larry/foo#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Nos hemos quedado solo con el fichero "shells", 
  pero no nos quejaremos. N&oacute;tese que rm por defecto no preguntara antes 
  de borrar un fichero, luego, sea cuidadoso.<br>
  </font><font color="#000000" size="2">Una orden relacionada con rm es rmdir. 
  Esta orden borra un directorio, pero solo si esta vac&iacute;o. Si el directorio 
  contiene ficheros o subdirectorios, rmdir se quejara.</font></P>
<P><font color="#000000" size="2"><u><a name="3.3.7"></a>3.3.7 Mirando los ficheros<br>
  <font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.3.6">Anterior</a>- 
  <a href="#3.3.8">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"></font></u></b><u></u><u><br>
  </u></font></P>
<P><font color="#000000" size="2">Las &oacute;rdenes more y cat son usadas para 
  ver el contenido de ficheros. more muestra el fichero pantalla a pantalla mientras 
  que cat lo muestra entero de una vez.<br>
  </font><font color="#000000" size="2">Para 
  ver el contenido del fichero shells podemos usar la orden</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry/foo# more shells</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Por si esta interesado en el contenido de shells, 
  es una lista de interpretes de comandos validos disponibles en el sistema. En 
  la mayor&iacute;a de los sistemas incluye /bin/sh, /bin/bash y /bin/csh.<br>
  </font><font color="#000000" size="2">Hablaremos sobre los diferentes interpretes 
  de comandos mas adelante.<br>
  </font><font color="#000000" size="2">Durante la ejecuci&oacute;n de more pulse 
  |_Space_| para avanzar a la pagina siguiente y |_b_| para volver a la pagina 
  anterior. Hay otros comandos disponibles, los citados son solo los mas b&aacute;sicos. 
  |_q_| finalizara la ejecuci&oacute;n de more.<br>
  </font><font color="#000000" size="2">Salga de more y pruebe cat /etc/termcap. 
  El texto probablemente pasara demasiado r&aacute;pido como para poder leerlo. 
  El nombre "cat" viene de "concatenate", que es para lo que realmente sirve el 
  programa. La orden cat puede ser usada para concatenar el contenido de varios 
  ficheros y guardar el resultado en otro fichero. Esto se discutir&aacute; mas 
  adelante.</font></P>
<P><font color="#000000" size="2"><u><a name="3.3.8"></a>3.3.8 Obteniendo ayuda 
  en l&iacute;nea<br>
  <font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.3.7">Anterior</a>- 
  <a href="#3.4">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"></font></u></b><u></u><u><br>
  </u></font></P>
<P><font color="#000000" size="2">Pr&aacute;cticamente cada sistema UNIX, incluido 
  Linux, proporciona una utilidad conocida como "paginas de manual". Estas paginas 
  contienen documentaci&oacute;n en l&iacute;nea para todas las &oacute;rdenes 
  del sistema, recursos, ficheros de configuraci&oacute;n, etc.<br>
  </font><font color="#000000" size="2">La 
  orden usada para acceder a las paginas de manual es man. Por ejemplo, si esta 
  interesado en conocer otras opciones de la orden ls, puede escribir</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# man ls</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">y le ser&aacute; mostrada la pagina de manual 
  para ls.<br>
  </font><font color="#000000" size="2">Desafortunadamente la mayor&iacute;a de 
  las paginas de manual han sido escritas por gente que ya conoc&iacute;a lo que 
  la orden o recurso hacia, por esto, las paginas de manual usualmente solo contienen 
  detalles t&eacute;cnicos de la orden sin ning&uacute;n tipo de tutorial de uso. 
  Pese a esto, estas paginas son una gran fuente de informaci&oacute;n que permiten 
  refrescar la memoria si olvidamos la sintaxis de un comando. Igualmente, estas 
  paginas le dar&aacute;n mucha informaci&oacute;n sobre &oacute;rdenes que no 
  trataremos en este libro.<br>
  </font><font color="#000000" size="2">Le sugiero que pruebe man con los comandos 
  que ya hemos tratado y con los que vayamos introduciendo. Notara que alguno 
  de los comandos no tiene pagina de manual. Esto puede ser debido a diferentes 
  motivos. En primer lugar, las paginas no han sido escritas aun (el Proyecto 
  de Documentaci&oacute;n de Linux es tambi&eacute;n el responsable de las paginas 
  de manual). En segundo lugar, la orden puede ser interna del int&eacute;rprete 
  de comandos, o un alias (como los tratados en la Secci&oacute;n 3.2.4), en cuyo 
  caso no tendr&aacute;n una pagina propia. Un ejemplo es la orden cd la cual 
  es interna del int&eacute;rprete de comandos. El propio int&eacute;rprete de 
  comandos es quien procesa cd, no hay un programa separado.</font></P>
<P><font color="#000000" size="2"><b><u><a name="3.4"></a><font size="3">3.4 Sumario 
  de &Oacute;rdenes B&aacute;sicas<br>
  </font></u></b><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.3.8">Anterior</a>- 
  <a href="#3.5">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font><font size="3"><br>
  </font></u></font></P>
<P><font color="#000000" size="2">Esta secci&oacute;n introduce algunos de las 
  &oacute;rdenes b&aacute;sicas mas &uacute;tiles de un sistema UNIX, incluidas 
  las ya cubiertas en las secciones anteriores.<br>
  </font><font color="#000000" size="2">N&oacute;tese que las opciones usualmente 
  comienzan con "-" y en la mayor&iacute;a de los casos se pueden a&ntilde;adir 
  m&uacute;ltiples opciones de una letra con un &uacute;nico "-". Por ejemplo, 
  en lugar de usar ls -l -F es posible usar ls -lF.<br>
  </font><font color="#000000" size="2">En lugar de listar todas las opciones 
  disponibles para cada uno de los comandos solo hablaremos de aquellas mas &uacute;tiles 
  o importantes. De hecho, la mayor&iacute;a de las &oacute;rdenes tienen un gran 
  n&uacute;mero de opciones (muchas de las cuales nunca usara). Puede usar man 
  para ver las paginas de manual de cada orden, la cual mostrar&aacute; la lista 
  completa de opciones disponibles.<br>
  </font><font color="#000000" size="2">N&oacute;tese tambi&eacute;n, que la mayor&iacute;a 
  de las &oacute;rdenes toman una lista de ficheros o directorios como argumentos, 
  denotados como "&lt;fichero1&gt; . . . &lt;ficheroN&gt;". Por ejemplo, la orden 
  cp toma como argumentos la lista de ficheros a copiar, seguidos del fichero 
  o directorio destino. Cuando se copia mas de un fichero, el destino debe de 
  ser un directorio.<br>
  </font><font size="2" color="#000000"><B><br>
  cd</b> Cambia el directorio de trabajo actual.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">Sintaxis: cd &lt;directorio&gt;<br>
      </font><font color="#000000" size="2">&lt;directorio&gt; es el directorio 
      al que cambiamos. ("." se refiere al directorio actual, ".." al directorio 
      padre.)<br>
      </font><font color="#000000" size="2">Ejemplo: cd ../foo pone ../foo 
      como directorio actual.</font></P>
  </DIR>
</DIR>
<P><font size="2" color="#000000"><B>ls</b> Muestra informaci&oacute;n sobre los 
  ficheros o directorios indicados.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">Sintaxis: ls &lt;fichero1&gt; &lt;fichero2&gt; 
      ...&lt;ficheroN&gt;<br>
      </font><font color="#000000" size="2">Donde &lt;fichero1&gt; a &lt;ficheroN&gt; 
      son los ficheros o directorios a listar.<br>
      </font><font color="#000000" size="2">Opciones: Hay mas opciones de las 
      que podr&iacute;a suponer. Las mas usadas com&uacute;nmente son: -F (usada 
      para mostrar informaci&oacute;n sobre el tipo de fichero), y -l (da un listado 
      "largo" incluyendo tama&ntilde;o, propietario, permisos, etc. Trataremos 
      esto en detalle mas adelante.)<br>
      </font><font color="#000000" size="2">Ejemplo: 
      ls -lF /home/larry mostrar&aacute; el contenido del directorio /home/larry.</font></P>
  </DIR>
</DIR>
<P><font size="2" color="#000000"><B>cp</b> Copia fichero(s) en otro fichero o 
  directorio.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">Sintaxis: cp &lt;fichero1&gt; &lt;fichero2&gt; 
      ...&lt;ficheroN&gt; &lt;destino&gt;<br>
      </font><font color="#000000" size="2">Donde &lt;fichero1&gt; a &lt;ficheroN&gt; 
      son los ficheros a copiar, y &lt;destino&gt; es el fichero o directorio 
      destino.<br>
      </font><font color="#000000" size="2">Ejemplo: cp ../frog joe copia 
      el fichero ../frog al fichero o directorio joe.</font></P>
  </DIR>
</DIR>
<P><font size="2" color="#000000"><B>mv</b> Mueve fichero(s) a otro fichero o 
  directorio. Es equivalente a una copia seguida del borrado del original. Puede 
  ser usado para renombrar ficheros, como el comando MS-DOS RENAME.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">Sintaxis: mv &lt;fichero1&gt; &lt;fichero2&gt; 
      ...&lt;ficheroN&gt; &lt;destino&gt;<br>
      </font><font color="#000000" size="2">Donde &lt;fichero1&gt; a &lt;ficheroN&gt; 
      son los ficheros a "mover" y &lt;destination&gt; es el fichero o directorio 
      destino.<br>
      </font><font color="#000000" size="2">Ejemplo: mv ../frog joe mueve 
      el fichero ../frog al fichero o directorio joe.</font></P>
  </DIR>
</DIR>
<P><font size="2" color="#000000"><B>rm</b> Borra ficheros. N&oacute;tese que 
  cuando los ficheros son borrados en UNIX, son irrecuperables (a diferencia de 
  MS-DOS, donde usualmente se puede recuperar un fichero borrado).</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">Sintaxis: rm &lt;fichero1&gt; &lt;fichero2&gt; 
      ...&lt;ficheroN&gt;<br>
      </font><font color="#000000" size="2">Donde &lt;fichero1&gt; a &lt;ficheroN&gt; 
      son los nombres de los ficheros a borrar.<br>
      </font><font color="#000000" size="2">Opciones: -i pedir&aacute; confirmaci&oacute;n 
      antes de borrar un fichero.<br>
      </font><font color="#000000" size="2">Ejemplo: 
      rm -i /home/larry/joe /home/larry/frog borra los ficheros joe y frog en 
      /home/larry.</font></P>
  </DIR>
</DIR>
<P><font size="2" color="#000000"><B>mkdir</b> Crea directorios nuevos.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">Sintaxis: mkdir &lt;dir1&gt; &lt;dir2&gt; 
      ...&lt;dirN&gt;<br>
      </font><font color="#000000" size="2">Donde &lt;dir1&gt; a &lt;dirN&gt; 
      son los directorios a crear.<br>
      </font><font color="#000000" size="2">Ejemplo: 
      mkdir /home/larry/test crea el directorio test colgando de /home/larry.</font></P>
  </DIR>
</DIR>
<P><font size="2" color="#000000"><B>rmdir</b> Esta orden borra directorios vac&iacute;os. 
  Al usar rmdir, el directorio de trabajo actual no debe de estar dentro del directorio 
  a borrar.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">Sintaxis: rmdir &lt;dir1&gt; &lt;dir2&gt; 
      ...&lt;dirN&gt;<br>
      </font><font color="#000000" size="2">Donde &lt;dir1&gt; 
      a &lt;dirN&gt; son los directorios a borrar.<br>
      </font><font color="#000000" size="2">Ejemplo: rmdir /home/larry/papers 
      borra el directorio /home/larry/papers si esta vac&iacute;o.</font></P>
  </DIR>
</DIR>
<P><font size="2" color="#000000"><B>man</b> Muestra la pagina de manual del comando 
  o recurso (cualquier utilidad del sistema que no es un comando, como funciones 
  de librer&iacute;a) dado. </font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">Sintaxis: man &lt;command&gt;<br>
      </font><font color="#000000" size="2">Donde 
      &lt;command&gt; es el nombre del comando o recurso sobre el que queremos 
      obtener la ayuda.<br>
      </font><font color="#000000" size="2">Ejemplo: man ls muestra ayuda sobre 
      la orden ls.</font></P>
  </DIR>
</DIR>
<P><font size="2" color="#000000"><B>more</b> Muestra el contenido de los ficheros 
  indicados, una pantalla cada vez.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">Sintaxis: more &lt;fichero1&gt; &lt;fichero2&gt; 
      ...&lt;ficheroN&gt;<br>
      </font><font color="#000000" size="2">Donde &lt;fichero1&gt; 
      a &lt;ficheroN&gt; son los ficheros a mostrar.<br>
      </font><font color="#000000" size="2">Ejemplo: more papers/history-final 
      muestra por el terminal el contenido del fichero papers/history-final.</font></P>
  </DIR>
</DIR>
<P><font size="2" color="#000000"><B>cat</b> Oficialmente usado para concatenar 
  ficheros, cat tambi&eacute;n es usado para mostrar el contenido completo de 
  un fichero de una vez.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">Sintaxis: cat &lt;fichero1&gt; &lt;fichero2&gt; 
      ...&lt;ficheroN&gt;<br>
      </font><font color="#000000" size="2">Donde &lt;fichero1&gt; a &lt;ficheroN&gt; 
      son los ficheros a mostrar.<br>
      </font><font color="#000000" size="2">Ejemplo: 
      cat letters/from-mdw muestra por el terminal el contenido del fichero letters/from-mdw.</font></P>
  </DIR>
</DIR>
<P><font size="2" color="#000000"><B>echo</b> Simplemente env&iacute;a al terminal 
  los argumentos pasados.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">Sintaxis: echo &lt;arg1&gt; &lt;arg2&gt; 
      ...&lt;argN&gt;<br>
      </font><font color="#000000" size="2">Donde &lt;arg1&gt; a &lt;argN&gt; 
      son los argumentos a mostrar.<br>
      </font><font color="#000000" size="2">Ejemplo: 
      echo ''Hola mundo'' muestra la cadena "Hola mundo".</font></P>
  </DIR>
</DIR>
<P><font size="2" color="#000000"><B>grep</b> Muestra todas las l&iacute;neas 
  de un fichero dado que coinciden con un cierto patr&oacute;n.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">Sintaxis: grep &lt;patr&oacute;n&gt; &lt;fichero1&gt; 
      &lt;fichero2&gt; ...&lt;ficheroN&gt;<br>
      </font><font color="#000000" size="2">Donde &lt;patr&oacute;n&gt; es una 
      expresi&oacute;n regular y &lt;fichero1&gt; a &lt;ficheroN&gt; son los ficheros 
      donde buscar.<br>
      </font><font color="#000000" size="2">Ejemplo: grep loomer 
      /etc/hosts mostrar&aacute; todas las l&iacute;neas en el fichero /etc/hosts 
      que contienen la cadena "loomer".</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2"><b><u><a name="3.5"></a><font size="3">3.5 Explorando 
  el Sistema de Ficheros<br>
  </font></u></b><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.4">Anterior</a>- 
  <a href="#3.6">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"><br>
  </font></u></b></font></P>
<P><font color="#000000" size="2">El sistema de ficheros es la colecci&oacute;n 
  de ficheros y la jerarqu&iacute;a de directorios de su sistema. Le prometimos 
  acompa&ntilde;arle por el sistema de ficheros, y ha llegado el momento.<br>
  </font><font color="#000000" size="2">Tiene el nivel y conocimientos para entender 
  de lo que estamos hablando, adem&aacute;s de una gu&iacute;a de carreteras. 
  (Figura 3.1 en la pagina 85).<br>
  </font><font color="#000000" size="2">Primero cambie 
  al directorio ra&iacute;z (cd /) y ejecute ls -F. Probablemente vera estos directorios2:</font></P>
<P><font color="#000000" size="2">bin, dev, etc, home, install, lib, mnt, proc, 
  root, tmp, user, usr, y var.<br>
  </font><font color="#000000" size="2">Echemos un 
  vistazo a cada uno de estos directorios.</font></P>
<P><font size="2" color="#000000"><B>/bin</b> /bin es la abreviaci&oacute;n de 
  "binaries", o ejecutables. Es donde residen la mayor&iacute;a de los programas 
  esenciales del sistema. Use la orden "ls -F /bin" para listar los ficheros. 
  Podr&aacute; ver algunas &oacute;rdenes que reconocer&aacute;, como cp, ls y 
  mv. Estos son los programas para estas &oacute;rdenes. Cuando usa la orden cp 
  esta ejecutando el programa /bin/cp.<br>
  </font><font color="#000000" size="2">Usando 
  ls -F vera que la mayor&iacute;a (si no todos) los ficheros de /bin tienen un 
  asterisco ("*") a&ntilde;adido al final de sus nombres. Esto indica que son 
  ficheros ejecutables, como describe la Secci&oacute;n 3.3.2.</font></P>
<P><font size="2" color="#000000"><B>/dev</b> El siguiente es /dev. Ech&eacute;mosle 
  un vistazo de nuevo con ls -F.<br>
  </font><font color="#000000" size="2">Los "ficheros" en /dev son conocidos como 
  controladores de dispositivo (device drivers), son usados para acceder a los 
  dispositivos del sistema y recursos, como discos duros, m&oacute;dems, memoria, 
  etc. Por ejemplo, de la misma forma que puede leer datos de un fichero, puede 
  leerla desde la entrada del rat&oacute;n leyendo /dev/mouse.<br>
  </font><font color="#000000" size="2">Los 
  ficheros que comienzan su nombre con fd son controladores de disqueteras. fd0 
  es la primera disquetera, fd1 la segunda. Ahora, alguien astuto se dar&aacute; 
  cuenta de que hay mas controladores de dispositivo para disqueteras de los que 
  hemos mencionado. Estos representan tipos espec&iacute;ficos de discos. Por 
  ejemplo, fd1H1440 acceder&aacute; a discos de 3.5" de alta densidad en la disquetera 
  1.<br>
  </font><font color="#000000" size="2">Aqu&iacute; tenemos una lista de algunos 
  de los controladores de dispositivo mas usados. N&oacute;tese que incluso aunque 
  puede que no tenga alguno de los dispositivos listados, tendr&aacute; entradas 
  en dev de cualquier forma.</font></P>
<DIR> 
  <DIR> 
    <P><font size="2" color="#000000"><B>o</b> /dev/console hace referencia a 
      la consola del sistema, es decir, al monitor conectado directamente a su 
      sistema.<br>
      </font><font size="2" color="#000000"><B>o</b> Los dispositivos /dev/ttyS 
      y /dev/cua son usados para acceder a los puertos serie. Por ejemplo, /dev/ttyS0 
      hace referencia a "COM1" bajo MS-DOS. Los dispositivos /dev/cua son "callout", 
      los cuales son usados en conjunci&oacute;n con un m&oacute;dem.<br>
      </font><font size="2" color="#000000"><B>o</b> Los nombres de dispositivo 
      que comienzan por hd acceden a discos duros. /dev/hda hace referencia a 
      la totalidad del primer disco duro, mientras que /dev/hda1 hace referencia 
      a la primera partici&oacute;n en /dev/hda.<br>
      </font><font size="2" color="#000000"><B>o</b> Los nombres de dispositivo 
      que comienzan con sd son dispositivos SCSI. Si tiene un disco duro SCSI, 
      en lugar de acceder a &eacute;l mediante /dev/hda, deber&aacute; acceder 
      a /dev/sda. Las cintas SCSI son accedidas v&iacute;a dispositivos st y los 
      CD-ROM SCSI v&iacute;a sr.<br>
      </font><font size="2" color="#000000"><B>o</b> Los nombres que comienzan 
      por lp acceden a los puertos paralelo. /dev/lp0 hace referencia a "LPT1" 
      en el mundo MS-DOS.<br>
      </font><font size="2" color="#000000"><B>o</b> /dev/null es usado como "agujero 
      negro", cualquier dato enviado a este dispositivo desaparece. ¿Para que 
      puede ser &uacute;til esto?. Bien, si desea suprimir la salida por pantalla 
      de una orden, podr&iacute;a enviar la salida a /dev/null. Hablaremos mas 
      sobre esto despu&eacute;s.<br>
      </font><font size="2" color="#000000"><B>o</b> Los nombres que comienzan 
      por /dev/tty hacen referencia a "consolas virtuales" de su sistema (accesibles 
      mediante las teclas |_alt-F1_|, |_alt-F2_|, etc).<br>
      </font><font color="#000000" size="2">/dev/tty1 hace referencia a la primera 
      VC, /dev/tty2 a la segunda, etc.<br>
      </font><font size="2" color="#000000"><B>o</b> 
      Los nombres de dispositivo que comienzan con /dev/pty son "pseudoterminales". 
      Estos son usados para proporcionar un "terminal" a sesiones remotas. Por 
      ejemplo, si su maquina esta en una red, telnet de entrada usara uno de los 
      dispositivos /dev/pty.</font></P>
  </DIR>
</DIR>
<P><font size="2" color="#000000"><B>/etc</b> /etc contiene una serie de ficheros 
  de configuraci&oacute;n del sistema. Estos incluyen /etc/passwd (la base de 
  datos de usuarios), /etc/rc (guiones de inicializaci&oacute;n del sistema), 
  etc.</font></P>
<P><font size="2" color="#000000"><B>/sbin</b> sbin se usa para almacenar programas 
  esenciales del sistema, que usara el administrador del sistema.</font></P>
<P><font size="2" color="#000000"><B>/home</b> /home contiene los directorios 
  "home" de los usuarios. Por ejemplo, /home/larry es el directorio del usuario 
  "larry". En un sistema reci&eacute;n instalado, no habr&aacute; ning&uacute;n 
  usuario en este directorio.</font></P>
<P><font size="2" color="#000000"><B>/lib</b> /lib contiene las im&aacute;genes 
  de las librer&iacute;as compartidas. Estos ficheros contienen c&oacute;digo 
  que compartir&aacute;n muchos programas. En lugar de que cada programa contenga 
  una copia propia de las rutinas compartidas, estas son guardadas en un lugar 
  com&uacute;n, en /lib. Esto hace que los programas ejecutables sean menores 
  y reduce el espacio usado en disco.</font></P>
<P><font size="2" color="#000000"><B>/proc</b> /proc es un "sistema de ficheros 
  virtual". Los ficheros que contiene realmente residen en memoria, no en un disco. 
  Hacen referencia a varios procesos que corren en el sistema, y le permiten obtener 
  informaci&oacute;n acerca de que programas y procesos est&aacute;n corriendo 
  en un momento dado. Entraremos en mas detalles en la Secci&oacute;n 3.11.1.</font></P>
<P><font size="2" color="#000000"><B>/tmp</b> Muchos programas tienen la necesidad 
  de generar cierta informaci&oacute;n temporal y guardarla en un fichero temporal. 
  El lugar habitual para esos ficheros es en /tmp.</font></P>
<P><font size="2" color="#000000"><B>/usr</b> /usr es un directorio muy importante. 
  Contienen una serie de subdirectorios que contienen a su vez algunos de los 
  mas importantes y &uacute;tiles programas y ficheros de configuraci&oacute;n 
  usados en el sistema.<br>
  </font><font color="#000000" size="2">Los directorios descritos 
  arriba son esenciales para que el sistema este operativo, pero la mayor&iacute;a 
  de las cosas que se encuentran en /usr son opcionales para el sistema. De cualquier 
  forma, son estas cosas opcionales las que hacen que el sistema sea &uacute;til 
  e interesante. Sin /usr, tendr&iacute;a un sistema aburrido, solo con programas 
  como cp y ls. usr contiene la mayor&iacute;a de los paquetes grandes de programas 
  y sus ficheros de configuraci&oacute;n.</font></P>
<P><font size="2" color="#000000"><B>/usr/X386</b> /usr/X386 contiene el sistema 
  X Window si usted lo instala. El sistema X Window es un entorno gr&aacute;fico 
  grande y potente el cual proporciona un gran n&uacute;mero de utilidades y programas 
  gr&aacute;ficos, mostrados en "ventanas" en su pantalla. Si esta familiarizado 
  con los entornos Microsoft Windows o Macintosh, X Window le ser&aacute; muy 
  familiar. El directorio /usr/X386 contiene todos los ejecutables de X Window, 
  ficheros de configuraci&oacute;n y de soporte. Esto ser&aacute; cubierto con 
  mas detalle en la Secci&oacute;n 5.1.</font></P>
<P><font size="2" color="#000000"><B>/usr/bin</b> /usr/bin es el almac&eacute;n 
  real de programas del sistema UNIX. Contiene la mayor&iacute;a de los programas 
  que no se encuentran en otras partes como /bin.</font></P>
<P><font size="2" color="#000000"><B>/usr/etc</b> Como /etc contiene diferentes 
  ficheros de configuraci&oacute;n y programas del sistema, /usr/etc contiene 
  incluso mas que el anterior. En general, los ficheros que se encuentran en /usr/etc/ 
  no son esenciales para el sistema, a diferencia de los que se encuentran en 
  /etc, que si lo son.</font></P>
<P><font size="2" color="#000000"><B>/usr/include</b> /usr/include contiene los 
  ficheros de cabecera para el compilador de C. Estos ficheros (la mayor&iacute;a 
  de los cuales terminan en .h, de "header") declaran estructuras de datos, subrutinas 
  y constantes usados en la escritura de programas en C. Los ficheros que se encuentran 
  en /usr/include/sys son generalmente usados en la programaci&oacute;n de UNIX 
  a nivel de sistema. Si esta familiarizado con el lenguaje de programaci&oacute;n 
  C, aqu&iacute; encontrara los ficheros de cabecera como stdio.h, el cual declara 
  funciones como printf().</font></P>
<P><font size="2" color="#000000"><B>/usr/g++-include</b> /usr/g++-include contiene 
  ficheros de cabecera para el compilador de C++ (muy parecido a /usr/include).</font></P>
<P><font size="2" color="#000000"><B>/usr/lib</b> /usr/lib contiene las librer&iacute;as 
  equivalentes "stub" y "static" a los ficheros encontrados en /lib. Al compilar 
  un programa, este es "enlazado" con las librer&iacute;as que se encuentran en 
  /usr/lib, las cuales dirigen al programa a buscar en /lib cuando necesita el 
  c&oacute;digo de la librer&iacute;a. Adem&aacute;s, varios programas guardan 
  ficheros de configuraci&oacute;n en /usr/lib.</font></P>
<P><font size="2" color="#000000"><B>/usr/local</b> /usr/local es muy parecido 
  a /usr contiene programas y ficheros no esenciales para el sistema, pero que 
  hacen el sistema mas divertido y excitante. En general, los programas que se 
  encuentran en /usr/local son espec&iacute;ficos de su sistema, esto es, el directorio 
  /usr/local difiere bastante entre sistemas UNIX.<br>
  </font><font color="#000000" size="2">Aqu&iacute; 
  encontrara programas grandes como TEX (sistema de formateo de documentos) y 
  Emacs (gran y potente editor), si los instala.</font></P>
<P><font size="2" color="#000000"><B>/usr/man</b> Este directorio contiene las 
  paginas de manual. Hay dos subdirectorios para cada pagina "secci&oacute;n" 
  de las paginas (use la orden man man para mas detalles). Por ejemplo, /usr/man/man1 
  contiene los fuentes (es decir, los originales por formatear) de las paginas 
  de manual de la secci&oacute;n 1, y /usr/man/cat1 las paginas ya formateadas 
  de la secci&oacute;n 1.</font></P>
<P><font size="2" color="#000000"><B>/usr/src</b> /usr/src contiene el c&oacute;digo 
  fuente (programas por compilar) de varios programas de su sistema. El mas importante 
  es /usr/src/linux, el cual contiene el c&oacute;digo fuente del N&uacute;cleo 
  de Linux.</font></P>
<P><font size="2" color="#000000"><B>/var</b> /var contiene directorios que a 
  menudo cambian su tama&ntilde;o o tienden a crecer. Muchos de estos directorios 
  sol&iacute;an residir en /usr, pero desde que estamos tratando de dejarlo relativamente 
  inalterable, los directorios que cambian a menudo han sido llevados a /var. 
  Algunos de estos directorios son: &nbsp;</font></P>
<P><font size="2" color="#000000"><B>/var/adm</b> /var/adm contiene varios ficheros 
  de inter&eacute;s para el administrador del sistema, espec&iacute;ficamente 
  hist&oacute;ricos del sistema, los cuales recogen errores o problemas con el 
  sistema. Otros ficheros guardan las sesiones de presentaci&oacute;n en el sistema, 
  as&iacute; como los intentos fallidos. Esto ser&aacute; cubierto en el Capitulo 
  4.</font></P>
<P><font size="2" color="#000000"><B>/var/spool</b> /var/spool contiene ficheros 
  que van a ser pasados a otro programa. Por ejemplo, si su maquina esta conectada 
  a una red, el correo de llegada ser&aacute; almacenado en /var/spool/mail hasta 
  que lo lea o lo borre. Art&iacute;culos nuevos de las news" tanto salientes 
  como entrantes pueden encontrarse en /var/spool/news, etc.</font></P>
<P><font color="#000000" size="2"><b><u><a name="3.6"></a><font size="3">3.6 Tipos 
  de int&eacute;rpretes de comandos<br>
  </font></u></b><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.5">Anterior</a>- 
  <a href="#3.7">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"><br>
  </font></u></b></font></P>
<P><font color="#000000" size="2">Como hemos mencionado anteriormente en numerosas 
  ocasiones, UNIX es un sistema operativo multitarea y multiusuario. La multitarea 
  es muy &uacute;til, y una vez la haya probado, la usara continuamente. En poco 
  tiempo podr&aacute; ejecutar programas "de fondo", conmutar entre m&uacute;ltiples 
  tareas y "entubar" programas unos entre otros para conseguir resultados complejos 
  con un &uacute;nico comando.<br>
  </font><font color="#000000" size="2">Muchas de las caracter&iacute;sticas que 
  trataremos en esta secci&oacute;n son proporcionadas por el int&eacute;rprete 
  de comandos. Hay que tener cuidado en no confundir UNIX (el sistema operativo) 
  con el int&eacute;rprete de comandos, este &uacute;ltimo, es un interface con 
  el sistema que hay debajo. El int&eacute;rprete de comandos proporciona la funcionalidad 
  sobre el UNIX.<br>
  </font><font color="#000000" size="2">El int&eacute;rprete de comandos no es 
  solo un int&eacute;rprete interactivo de los comandos que tecleamos, es tambi&eacute;n 
  un potente lenguaje de programaci&oacute;n, el cual permite escribir guiones, 
  que permiten juntar varias &oacute;rdenes en un fichero. Los usuarios de MS-DOS 
  reconocer&aacute;n esto como los ficheros "batch". El uso de los guiones del 
  int&eacute;rprete de comandos es una herramienta muy potente que le permitir&aacute; 
  automatizar e incrementar el uso de UNIX. Ver la secci&oacute;n 3.13.1 para 
  mas informaci&oacute;n.<br>
  </font><font color="#000000" size="2">Hay varios tipos de interpretes de comandos 
  en el mundo UNIX. Los dos mas importantes son el "Bourne shell" y el "C shell". 
  El int&eacute;rprete de comandos Bourne, usa una sintaxis de comandos como la 
  usada en los primeros sistemas UNIX, como el System III. El nombre del int&eacute;rprete 
  Bourne en la mayor&iacute;a de los UNIX es /bin/sh (donde sh viene de "shell", 
  int&eacute;rprete de comandos en ingles).<br>
  </font><font color="#000000" size="2">El int&eacute;rprete C usa una sintaxis 
  diferente, a veces parecida a la del lenguaje de programaci&oacute;n C, y en 
  la mayor&iacute;a de los sistemas UNIX se encuentra como /bin/csh.<br>
  </font><font color="#000000" size="2">Bajo Linux hay algunas diferencias en 
  los interpretes de comandos disponibles. Dos de los mas usados son el "Bourne 
  Again Shell" o "Bash" (/bin/bash) y Tcsh (/bin/tcsh). Bash es un equivalente 
  al Bourne con muchas caracter&iacute;sticas avanzadas de la C shell. Como Bash 
  es un superconjunto de la sintaxis del Bourne, cualquier gui&oacute;n escrito 
  para el int&eacute;rprete de comandos Bourne standard funcionara en Bash. Para 
  los que prefieren el uso del int&eacute;rprete de comandos C, Linux tiene el 
  Tcsh, que es una versi&oacute;n extendida del C original.<br>
  </font><font color="#000000" size="2">El tipo de int&eacute;rprete de comandos 
  que decida usar es puramente una cuesti&oacute;n de gustos. Algunas personas 
  prefieren la sintaxis del Bourne con las caracter&iacute;sticas avanzadas que 
  proporciona Bash, y otros prefieren el mas estructurado int&eacute;rprete de 
  comandos C. En lo que respecta a los comandos usuales como cp, ls..etc, es indiferente 
  el tipo de int&eacute;rprete de comandos usado, la sintaxis es la misma. Solo, 
  cuando se escriben guiones para el int&eacute;rprete de comandos, o se usan 
  caracter&iacute;sticas avanzadas aparecen las diferencias entre los diferentes 
  interpretes de comandos.<br>
  </font><font color="#000000" size="2">Como estamos discutiendo sobre las diferencias 
  entre los interpretes de comandos Bourne y C, abajo veremos esas diferencias. 
  Para los prop&oacute;sitos de este manual, la mayor&iacute;a de las diferencias 
  son m&iacute;nimas. (Si eres realmente curioso a este respecto, lee las paginas 
  de manual para bash y tcsh).</font></P>
<P><font color="#000000" size="2"><b><u><a name="3.7"></a><font size="3">3.7 Caracteres 
  comod&iacute;n<br>
  </font></u></b><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.6">Anterior</a>- 
  <a href="#3.8">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"><br>
  </font></u></b></font></P>
<P><font color="#000000" size="2">Una caracter&iacute;stica importante de la mayor&iacute;a 
  de los interpretes de comandos en Unix es la capacidad para referirse a mas 
  de un fichero usando caracteres especiales. Estos llamados comodines le permiten 
  referirse a, por ejemplo, todos los ficheros que contienen el car&aacute;cter 
  "&ntilde;".<br>
  </font><font color="#000000" size="2">El comod&iacute;n "*" hace referencia 
  cualquier car&aacute;cter o cadena de caracteres en el fichero. Por ejemplo, 
  cuando usa el car&aacute;cter "*" en el nombre de un fichero, el int&eacute;rprete 
  de comandos lo sustituye por todas las combinaciones posibles provenientes de 
  los ficheros en el directorio al cual nos estamos refiriendo.<br>
  </font><font color="#000000" size="2">Veamos 
  un ejemplo r&aacute;pido. Supongamos que Larry tiene los ficheros frog, joe 
  y stuff en el directorio actual.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# ls<br>
      </font><font color="#000000" size="2">frog joe stuff<br>
      </font><font color="#000000" size="2">/home/larry#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Para acceder a todos los ficheros con la letra 
  "o" en su nombre, hemos de usar la orden</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# ls *o*<br>
      </font><font color="#000000" size="2">frog joe<br>
      </font><font color="#000000" size="2">/home/larry#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Como puede ver, el comod&iacute;n "*" ha sido 
  sustituido con todas las combinaciones posibles que coincid&iacute;an de entre 
  los ficheros del directorio actual.<br>
  </font><font color="#000000" size="2">El 
  uso de "*" solo, simplemente se refiere a todos los ficheros, puesto que todos 
  los caracteres coinciden con el comod&iacute;n.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# ls *<br>
      </font><font color="#000000" size="2">frog joe stuff<br>
      </font><font color="#000000" size="2">/home/larry#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Veamos unos pocos ejemplos mas.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# ls f*<br>
      </font><font color="#000000" size="2">frog<br>
      </font><font color="#000000" size="2">/home/larry# ls *ff<br>
      </font><font color="#000000" size="2">stuff<br>
      </font><font color="#000000" size="2">/home/larry# ls *f*<br>
      </font><font color="#000000" size="2">frog stuff<br>
      </font><font color="#000000" size="2">/home/larry# ls s*f<br>
      </font><font color="#000000" size="2">stuff<br>
      </font><font color="#000000" size="2">/home/larry#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">El proceso de la sustituci&oacute;n de "*" en 
  nombres de ficheros es llamado expansi&oacute;n de comodines y es efectuado 
  por el int&eacute;rprete de comandos. Esto es importante: las &oacute;rdenes 
  individuales, como ls, nunca ven el "*" en su lista de par&aacute;metros. Es 
  el int&eacute;rprete quien expande los comodines para incluir todos los nombres 
  de ficheros que se adaptan. Luego la orden &nbsp;</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# ls *o*</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">es expandida para obtener</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# ls frog joe</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Una nota importante acerca del car&aacute;cter 
  comod&iacute;n "*". El uso de este comod&iacute;n NO cuadrara con nombres de 
  ficheros que comiencen con un punto ("."). Estos ficheros son tratados como 
  "ocultos", aunque no est&aacute;n realmente ocultos, simplemente no son mostrados 
  en un listado normal de ls y no son afectados por el uso del comod&iacute;n 
  "*".<br>
  </font><font color="#000000" size="2">He aqu&iacute; un ejemplo. Ya hemos 
  mencionado que cada directorio tiene dos entradas especiales: "." que hace referencia 
  al directorio actual y ".." que se refiere al directorio padre. De cualquier 
  forma, cuando use ls esas dos entradas no se mostraran.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# ls<br>
      </font><font color="#000000" size="2">frog joe stuff<br>
      </font><font color="#000000" size="2">/home/larry#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Si usa el par&aacute;metro -a con ls podr&aacute; 
  ver nombres de ficheros que comienzan por ".". Observe:</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# ls -a<br>
      </font><font color="#000000" size="2">. .. .bash_profile .bashrc frog joe 
      stuff<br>
      </font><font color="#000000" size="2">/home/larry#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Ahora podemos ver las dos entradas especiales, 
  "." y "..", as&iacute; como otros dos ficheros "ocultos", .bash_profile y .bashrc. 
  Estos dos ficheros son usados en el arranque por bash cuando larry se presenta 
  al sistema. Mas informaci&oacute;n sobre esto en la Secci&oacute;n 3.13.3. Note 
  que cuando usamos el comod&iacute;n "*", no se muestra ninguno de los nombres 
  de fichero que comienzan por ".".</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# ls *<br>
      </font><font color="#000000" size="2">frog joe stuff<br>
      </font><font color="#000000" size="2">/home/larry#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Esto es una caracter&iacute;stica de seguridad: 
  si "*" coincidiera con ficheros que comienzan por "." actuar&iacute;a sobre 
  "." y "..". Esto puede ser peligroso con ciertas &oacute;rdenes.<br>
  </font><font color="#000000" size="2">Otro 
  car&aacute;cter comod&iacute;n es "?". Este car&aacute;cter comod&iacute;n solo 
  expande un &uacute;nico car&aacute;cter. Luego "ls ?" mostrar&aacute; todos 
  los nombres de ficheros con un car&aacute;cter de longitud, y "ls termca?" mostrar&aacute; 
  "termcap" pero no "termcap.backup". Aqu&iacute; tenemos otro ejemplo:</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# ls j?e<br>
      </font><font color="#000000" size="2">joe<br>
      </font><font color="#000000" size="2">/home/larry# ls f??g<br>
      </font><font color="#000000" size="2">frog<br>
      </font><font color="#000000" size="2">/home/larry# ls ????f<br>
      </font><font color="#000000" size="2">stuff<br>
      </font><font color="#000000" size="2">/home/larry#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Como puede ver, los caracteres comod&iacute;n 
  le permiten referirse a mas de un fichero a la vez. En el resumen de &oacute;rdenes 
  en la Secci&oacute;n 3.4 dijimos que cp y mv pueden copiar o mover m&uacute;ltiples 
  ficheros de una vez. Por ejemplo,</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# cp /etc/s* /home/larry</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2"> copiara todos los ficheros de /etc que comiencen 
  por "s" al directorio /home/larry. Por lo tanto, el formato de la orden cp es 
  realmente</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">cp &lt;fichero1&gt; &lt;fichero2&gt; &lt;fichero3&gt; 
      ...&lt;ficheroN&gt; &lt;destino&gt;</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">donde &lt;fichero1&gt; a &lt;ficheroN&gt; es 
  la lista de los ficheros a copiar, y &lt;destino&gt; es el fichero o directorio 
  destino donde copiarlos. mv tiene id&eacute;ntica sintaxis.<br>
  </font><font color="#000000" size="2">N&oacute;tese que si esta copiando o moviendo 
  mas de un fichero, &lt;destino&gt; debe ser un directorio. Solo puede copiar 
  o mover un &uacute;nico fichero a otro fichero.</font></P>
<P><font color="#000000" size="2"><b><u><a name="3.8"></a><font size="3">3.8 Fontaner&iacute;a 
  UNIX<br>
  </font></u></b><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.7">Anterior</a>- 
  <a href="#3.8.1">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"><br>
  </font></u></b></font></P>
<P><font color="#000000" size="2"><u><a name="3.8.1"></a>3.8.1 Entrada y salida 
  est&aacute;ndar<br>
  <font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.8">Anterior</a>- 
  <a href="#3.8.2">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"></font></u></b><u><br>
  </u></font></P>
<P><font color="#000000" size="2">Muchos comandos UNIX toman su entrada de algo 
  conocido como entrada est&aacute;ndar y env&iacute;an su salida a la salida 
  est&aacute;ndar (a menudo abreviado como "stdin" y "stdout"). El int&eacute;rprete 
  de comandos configura el sistema de forma que la entrada est&aacute;ndar es 
  el teclado y la salida la pantalla.<br>
  </font><font color="#000000" size="2">Veamos 
  un ejemplo con el comando cat. Normalmente cat lee datos de los ficheros cuyos 
  nombres se pasan como argumentos en la l&iacute;nea de comandos y env&iacute;a 
  estos datos directamente a la salida est&aacute;ndar. Luego, usando el comando 
  &nbsp;</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry/papers# cat history-final masters-thesis</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">mostrar&aacute; por pantalla el contenido del 
  fichero history-final seguido por masters-thesis.<br>
  </font><font color="#000000" size="2">Si 
  no se le pasan nombres de ficheros a cat como par&aacute;metros, leer&aacute; 
  datos de stdin y los enviara a stdout. Veamos un ejemplo.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry/papers# cat<br>
      </font><font color="#000000" size="2">Hello there.<br>
      </font><font color="#000000" size="2">Hello there.<br>
      </font><font color="#000000" size="2">Bye.<br>
      </font><font color="#000000" size="2">Bye.<br>
      </font><font color="#000000" size="2">|_ctrl-D_|<br>
      </font><font color="#000000" size="2">/home/larry/papers#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Como se puede ver, cada l&iacute;nea que el 
  usuario teclea (impresa en it&aacute;lica) es inmediatamente reenviada al monitor 
  por cat. Cuando se esta leyendo de la entrada est&aacute;ndar, los comandos 
  reconocen el fin de la entrada de datos cuando reciben el car&aacute;cter EOT 
  (end-of-text, fin de texto). Normalmente es generado con la combinaci&oacute;n 
  |_ctrl-D_|.<br>
  </font><font color="#000000" size="2">Veamos otro ejemplo. El comando 
  sort toma como entrada l&iacute;neas de texto (de nuevo leer&aacute; desde stdin 
  si no se le proporcionan nombres de ficheros en la l&iacute;nea de comandos), 
  y devuelve la salida ordenada a stdout. Pruebe lo siguiente:</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry/papers# sort<br>
      </font><font color="#000000" size="2">bananas<br>
      </font><font color="#000000" size="2">carrots<br>
      </font><font color="#000000" size="2">apples___<br>
      </font><font color="#000000" size="2">|_ctrl-D_|<br>
      </font><font color="#000000" size="2">apples<br>
      </font><font color="#000000" size="2">bananas<br>
      </font><font color="#000000" size="2">carrots<br>
      </font><font color="#000000" size="2">/home/larry/papers#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Podemos ordenar alfab&eacute;ticamente la lista 
  de la compra... ¿no es &uacute;til UNIX?</font></P>
<P><font color="#000000" size="2"><u><a name="3.8.2"></a>3.8.2 Redireccionando 
  la entrada y salida<br>
  <font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.8.1">Anterior</a>- 
  <a href="#3.8.3">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"></font></u></b><u></u><u><br>
  </u></font></P>
<P><font color="#000000" size="2">Ahora, supongamos que queremos que la salida 
  de sort vaya a un fichero para poder salvar la lista ordenada de salida. El 
  int&eacute;rprete de comandos nos permite redireccionar la salida est&aacute;ndar 
  a un fichero usando el s&iacute;mbolo "&gt;". Veamos como funciona.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry/papers# sort &gt; shopping-list<br>
      </font><font color="#000000" size="2">bananas<br>
      </font><font color="#000000" size="2">carrots<br>
      </font><font color="#000000" size="2">apples<br>
      </font><font color="#000000" size="2">|_ctrl-D_|<br>
      </font><font color="#000000" size="2">/home/larry/papers#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Como puede ver, el resultado de sort no se muestra 
  por pantalla, en su lugar es salvado en el fichero shopping-list. Echemos un 
  vistazo al fichero.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry/papers# cat shopping-list<br>
      </font><font color="#000000" size="2">apples<br>
      </font><font color="#000000" size="2">bananas<br>
      </font><font color="#000000" size="2">carrots<br>
      </font><font color="#000000" size="2">/home/larry/papers#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Ya podemos ordenar la lista de la compra y adem&aacute;s 
  guardarla.<br>
  </font><font color="#000000" size="2">Supongamos ahora que ten&iacute;amos 
  guardada nuestra lista de compra desordenada original en el fichero &iacute;tems. 
  Una forma de ordenar la informaci&oacute;n y salvarla en un fichero podr&iacute;a 
  ser darle a sort el nombre del fichero a leer en lugar de la entrada est&aacute;ndar 
  y redireccionar la salida est&aacute;ndar como hicimos arriba.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry/papers# sort &iacute;tems &gt; 
      shopping-list<br>
      </font><font color="#000000" size="2">/home/larry/papers# cat shopping-list<br>
      </font><font color="#000000" size="2">apples<br>
      </font><font color="#000000" size="2">bananas<br>
      </font><font color="#000000" size="2">carrots<br>
      </font><font color="#000000" size="2">/home/larry/papers#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Hay otra forma de hacer esto. No solo puede 
  ser redireccionada la salida est&aacute;ndar, tambi&eacute;n puede ser redireccionada 
  la entrada est&aacute;ndar usando el s&iacute;mbolo "&lt;".</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry/papers# sort &lt; &iacute;tems<br>
      </font><font color="#000000" size="2">apples<br>
      </font><font color="#000000" size="2">bananas<br>
      </font><font color="#000000" size="2">carrots<br>
      </font><font color="#000000" size="2">/home/larry/papers#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">T&eacute;cnicamente, sort &lt; &iacute;tems 
  es equivalente a sort &iacute;tems, pero nos permite demostrar que sort &lt; 
  &iacute;tems se comporta como si los datos del fichero fueran tecleados por 
  la entrada est&aacute;ndar. El int&eacute;rprete de comandos es quien maneja 
  las redirecciones. sort no recibe el nombre del fichero (&iacute;tems) a leer, 
  desde el punto de vista de sort, esta leyendo datos de la entrada est&aacute;ndar 
  como si fueran tecleados desde el teclado.<br>
  </font><font color="#000000" size="2">Esto introduce el concepto de filtro. 
  Un filtro es un programa que lee datos de la entrada est&aacute;ndar, los procesa 
  de alguna forma, y devuelve los datos procesados por la salida est&aacute;ndar. 
  Usando la redirecci&oacute;n la entrada est&aacute;ndar y/o salida est&aacute;ndar 
  pueden ser referenciadas desde ficheros. Sort es un filtro simple: ordena los 
  datos de entrada y env&iacute;a el resultado a la salida est&aacute;ndar. cat 
  es incluso mas simple, no hace nada con los datos de entrada, simplemente env&iacute;a 
  a la salida cualquier cosa que le llega.</font></P>
<P><font color="#000000" size="2"><u><a name="3.8.3"></a>3.8.3 Uso de tuber&iacute;as 
  (pipes)<br>
  <font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.8.2">Anterior</a>- 
  <a href="#3.8.4">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"></font></u></b><u></u><u><br>
  </u></font></P>
<P><font color="#000000" size="2">Ya hemos visto como usar sort como un filtro. 
  Pero estos ejemplos suponen que tenemos los datos en un fichero en alguna parte 
  o vamos a introducir los datos manualmente por la entrada est&aacute;ndar.<br>
  </font><font color="#000000" size="2">¿Que pasa si los datos que queremos ordenar 
  provienen de la salida de otro comando, como ls?. Por ejemplo, usando la opci&oacute;n 
  -r con sort ordenaremos los datos en orden inverso. Si queremos listar los ficheros 
  en el directorio actual en orden inverso, una forma podr&iacute;a ser.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry/papers# ls<br>
      </font><font color="#000000" size="2">english-list<br>
      </font><font color="#000000" size="2">history-final<br>
      </font><font color="#000000" size="2">masters-thesis<br>
      </font><font color="#000000" size="2">notes<br>
      </font><font color="#000000" size="2">/home/larry/papers# ls &gt; file-list<br>
      </font><font color="#000000" size="2">/home/larry/papers# sort -r file-list<br>
      </font><font color="#000000" size="2">notes<br>
      </font><font color="#000000" size="2">masters-thesis<br>
      </font><font color="#000000" size="2">history-final<br>
      </font><font color="#000000" size="2">english-list<br>
      </font><font color="#000000" size="2">/home/larry/papers#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Aqu&iacute;, salvamos la salida de ls en un 
  fichero, y entonces ejecutamos sort -r sobre ese fichero. Pero esta forma necesita 
  crear un fichero temporal en el que salvar los datos generados por ls.<br>
  </font><font color="#000000" size="2">La 
  soluci&oacute;n es usar las pipes3. El uso de pipes es otra caracteristica del 
  int&eacute;rprete de comandos, que nos permite conectar una cadena de comandos 
  en un "pipe", donde la stdout del primero es enviada directamente a la stdin 
  del segundo y as&iacute; sucesivamente. Queremos conectar la salida de ls con 
  la entrada de sort. Para crear un pipe se usa el simbolo "|":</font></P>
<DIR> 
  <DIR> 
    <p><font color="#000000" size="2">/home/larry/papers# ls | sort -r<br>
      </font><font color="#000000" size="2">notes<br>
      </font><font color="#000000" size="2">masters-thesis<br>
      </font><font color="#000000" size="2">history-final<br>
      </font><font color="#000000" size="2">english-list<br>
      </font></p>
    <p><font color="#000000" size="2">/home/larry/papers#</font></p>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Esta forma es mas corta y obviamente mas facil 
  de escribir.<br>
  </font><font color="#000000" size="2">Otro ejemplo &uacute;til, 
  usando el comando</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry/papers# ls /usr/bin</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">mostrar&aacute; una lista larga de los ficheros, 
  la mayor&iacute;a de los cuales pasara r&aacute;pidamente ante nuestros ojos 
  sin que podamos leerla. En lugar de esto, usemos more para mostrar la lista 
  de ficheros en</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/usr/bin.<br>
      </font><font color="#000000" size="2">/home/larry/papers# 
      ls /usr/bin | more</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Ahora podemos ir avanzando pagina a pagina c&oacute;modamente.<br>
  </font><font color="#000000" size="2">¡Pero 
  la diversi&oacute;n no termina aqu&iacute;!. Podemos "entubar" mas de dos comandos 
  a la vez. El comando head es un filtro que muestra la primeras l&iacute;neas 
  del canal de entrada (aqu&iacute; la entrada desde una pipe). Si queremos ver 
  el &uacute;ltimo fichero del directorio actual en orden alfab&eacute;tico, usaremos:</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry/papers# ls | sort -r | head 
      -1<br>
      </font><font color="#000000" size="2">notes<br>
      </font><font color="#000000" size="2">/home/larry/papers#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Donde head -1 simplemente muestra la primera 
  l&iacute;nea de la entrada que recibe en este caso, el flujo de datos ordenados 
  inversamente provenientes de ls).</font></P>
<P><font color="#000000" size="2"><u><a name="3.8.4"></a>3.8.4 Redirecci&oacute;n 
  no destructiva<br>
  <font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.8.3">Anterior</a>- 
  <a href="#3.9">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"></font></u></b><u></u><u><br>
  </u></font></P>
<P><font color="#000000" size="2">El uso de "&gt;" para redireccionar la salida 
  a un fichero es destructivo: en otras palabras, el comando</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry/papers# ls &gt; file-list</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">sobrescribe el contenido del fichero file-list. 
  Si en su lugar, usamos el s&iacute;mbolo "&gt;&gt;", la salida ser&aacute; a&ntilde;adida 
  al final del fichero nombrado, en lugar de ser sobrescrito.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry/papers# ls &gt;&gt; file-list</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">a&ntilde;adir&aacute; la salida de ls al final 
  de file-list.<br>
  </font><font color="#000000" size="2">Es conveniente tener en cuenta que la 
  redirecci&oacute;n y el uso de pipes son caracter&iacute;sticas proporcionadas 
  por el int&eacute;rprete de comandos_ este, proporciona estos servicios mediante 
  el uso de la sintaxis "&gt;", "&gt;&gt;" y "|".</font></P>
<P><font color="#000000" size="2"><b><u><a name="3.9"></a><font size="3">3.9 Permisos 
  de Ficheros<br>
  </font></u></b><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.8.4">Anterior</a>- 
  <a href="#3.9.1">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font></u></font></u></font></u><u></u></font></u><b><u><font color="#000000" size="2"><u><br>
  </u></font><font size="3"><br>
  </font></u></b></font></P>
<P><font color="#000000" size="2"><u><a name="3.9.1"></a>3.9.1 Conceptos de permisos 
  de ficheros<br>
  <font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.9">Anterior</a>- 
  <a href="#3.9.2">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font></u></font></u></font></u><u></u></font></u><b><u><font color="#000000" size="2"><u></u></font></u></b><u><br>
  </u></font></P>
<P><font color="#000000" size="2">Al ser UNIX un sistema multiusuario, para proteger 
  ficheros de usuarios particulares de la manipulaci&oacute;n por parte de otros, 
  UNIX proporciona un mecanismo conocido como permisos de ficheros.<br>
  </font><font color="#000000" size="2">Este mecanismo permite que ficheros y 
  directorios "pertenezcan" a un usuario en particular. Por ejemplo, como Larry 
  creo ficheros en su directorio "home", Larry es el propietario de esos ficheros 
  y tiene acceso a ellos.<br>
  </font><font color="#000000" size="2">UNIX tambi&eacute;n permite que los ficheros 
  sean compartidos entre usuarios y grupos de usuarios. Si Larry lo desea, podr&iacute;a 
  restringir el acceso a sus ficheros de forma que ning&uacute;n otro usuario 
  tenga acceso. De cualquier modo, en la mayor&iacute;a de los sistemas por defecto 
  se permite que otros usuarios puedan leer tus ficheros pero no modificarlos 
  o borrarlos.<br>
  </font><font color="#000000" size="2">Como hemos explicado arriba, cada fichero 
  pertenece a un usuario en particular. Por otra parte, los ficheros tambi&eacute;n 
  pertenecen a un grupo en particular, que es un conjunto de usuarios definido 
  por el sistema. Cada usuario pertenece al menos a un grupo cuando es creado. 
  El administrador del sistema puede hacer que un usuario tenga acceso a mas de 
  un grupo.<br>
  </font><font color="#000000" size="2">Los grupos usualmente son definidos por 
  el tipo de usuarios que acceden a la maquina. Por ejemplo, en un sistema UNIX 
  de una universidad, los usuarios pueden ser divididos en los grupos estudiantes, 
  direcci&oacute;n, profesores e invitados. Hay tambi&eacute;n unos pocos grupos 
  definidos por el sistema (como bin y admin) los cuales son usados por el propio 
  sistema para controlar el acceso a los recursos, muy raramente los usuarios 
  normales pertenecen a estos grupos.<br>
  </font><font color="#000000" size="2">Los permisos est&aacute;n divididos en 
  tres tipos: lectura, escritura y ejecuci&oacute;n. Estos permisos pueden ser 
  fijados para tres clases de usuarios: el propietario del fichero, el grupo al 
  que pertenece el fichero y para todos los usuarios independientemente del grupo.<br>
  </font><font color="#000000" size="2">El permiso de lectura permite a un usuario 
  leer el contenido del fichero o en el caso de un directorio, listar el contenido 
  del mismo (usando ls). El permiso de escritura permite a un usuario escribir 
  y modificar el fichero. Para directorios, el permiso de escritura permite crear 
  nuevos ficheros o borrar ficheros ya existentes en dicho directorio. Por &uacute;ltimo, 
  el permiso de ejecuci&oacute;n permite a un usuario ejecutar el fichero si es 
  un programa o gui&oacute;n del int&eacute;rprete de comandos. Para directorios, 
  el permiso de ejecuci&oacute;n permite al usuario cambiar al directorio en cuesti&oacute;n 
  con cd.</font></P>
<P><font color="#000000" size="2"><u><a name="3.9.2"></a>3.9.2 Interpretando los 
  permisos de ficheros<br>
  <font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.9.1">Anterior</a>- 
  <a href="#3.9.3">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font></u></font></u></font></u><u></u></font></u><b><u><font color="#000000" size="2"><u></u></font></u></b><u></u><u><br>
  </u></font></P>
<P><font color="#000000" size="2">Veamos un ejemplo del uso de permisos de ficheros. 
  Usando el comando ls con la opci&oacute;n -l se mostrar&aacute; un listado "largo" 
  de los ficheros, el cual incluye los permisos de ficheros.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry/foo# ls -l stuff<br>
      </font><font color="#000000" size="2">-rw-r--r-- 1 larry users 505 Mar 13 
      19:05 stuff<br>
      </font><font color="#000000" size="2">/home/larry/foo#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">El primer campo impreso en el listado representa 
  los permisos de ficheros. El tercer campo es el propietario del fichero (larry), 
  y el cuarto es el grupo al cual pertenece el fichero (users).<br>
  </font><font color="#000000" size="2">Obviamente, el &uacute;ltimo campo es 
  el nombre del fichero (stuff), y los dem&aacute;s campos los trataremos mas 
  adelante.<br>
  </font><font color="#000000" size="2">Este fichero pertenece a larry y al grupo 
  users. Echemos un vistazo a los permisos. La cadena -rw-r--r-- nos informa, 
  por orden, de los permisos para el propietario, el grupo del fichero y cualquier 
  otro usuario.<br>
  </font><font color="#000000" size="2">El primer car&aacute;cter de la cadena 
  de permisos ("-") representa el tipo de fichero. El "-" significa que es un 
  fichero regular. Las siguientes tres letras ("rw-") representan los permisos 
  para el propietario del fichero, larry. El "r" para "lectura" y "w" para escritura. 
  Luego Larry tiene permisos de lectura y escritura para el fichero stuff.<br>
  </font><font color="#000000" size="2">Como ya mencionamos, aparte de los permisos 
  de lectura y escritura esta el permiso de ejecuci&oacute;n", representado por 
  una "x". Como hay un "-" en lugar del "x", significa que Larry no tiene permiso 
  para ejecutar ese fichero. Esto es correcto, puesto que stuff no es un programa 
  de ning&uacute;n tipo. Por supuesto, como el fichero es de Larry, puede darse 
  a si mismo permiso de ejecuci&oacute;n si lo desea. Esto ser&aacute; cubierto 
  en breve.<br>
  </font><font color="#000000" size="2">Los siguientes tres caracteres, r-- representan 
  los permisos para los miembros del grupo. El grupo al que pertenece el fichero 
  es users. Como solo aparece un "r" cualquier usuario que pertenezca al grupo 
  users puede leer este fichero.<br>
  </font><font color="#000000" size="2">Los &uacute;ltimos tres caracteres, tambi&eacute;n 
  r--, representan los permisos para cualquier otro usuario del sistema (diferentes 
  del propietario o de los pertenecientes al grupo users). De nuevo, como solo 
  esta presente el "r", los dem&aacute;s usuarios pueden leer el fichero, pero 
  no escribir en el o ejecutarlo.<br>
  </font><font color="#000000" size="2">Aqu&iacute; 
  tenemos otros ejemplos de permisos de grupo.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">-rwxr-xr-x El propietario del fichero puede 
      leer, escribir y ejecutar el fichero. Los usuarios pertenecientes al grupo 
      del fichero, y todos los dem&aacute;s usuarios pueden leer y ejecutar el 
      fichero.</font></P>
    <P><font color="#000000" size="2">-rw------- El propietario del fichero puede 
      leer y escribir. Nadie mas puede acceder al fichero.</font></P>
    <P><font color="#000000" size="2">-rwxrwxrwx Todos los usuarios pueden leer, 
      escribir y ejecutar el fichero.</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2"><u><a name="3.9.3"></a>3.9.3 Dependencias<br>
  <font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.9.2">Anterior</a>- 
  <a href="#3.9.4">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font></u></font></u></font></u><u></u></font></u><b><u><font color="#000000" size="2"><u></u></font></u></b><u></u><u><br>
  </u></font></P>
<P><font color="#000000" size="2">Es importante darse cuenta de que los permisos 
  de un fichero tambi&eacute;n dependen de los permisos del directorio en el que 
  residen. Por ejemplo, aunque un fichero tenga los permisos -rwxrwxrwx, otros 
  usuarios no podr&aacute;n acceder a &eacute;l a menos que tambi&eacute;n tengan 
  permiso de lectura y ejecuci&oacute;n para el directorio en el cual se encuentra 
  el fichero. Si Larry quiere restringir el acceso a todos sus ficheros, podr&iacute;a 
  simplemente poner los permisos de su directorio "home" /home/larry a -rwx------. 
  De esta forma ning&uacute;n usuario podr&aacute; acceder a su directorio ni 
  a ninguno de sus ficheros o subdirectorios.<br>
  </font><font color="#000000" size="2">Larry no necesita preocuparse de los permisos 
  individuales de cada uno de sus ficheros.<br>
  </font><font color="#000000" size="2">En otras palabras, para acceder a un fichero, 
  debes de tener permiso de ejecuci&oacute;n de todos los directorios a lo largo 
  del camino de acceso al fichero, adem&aacute;s de permiso de lectura (o ejecuci&oacute;n) 
  del fichero en particular.<br>
  </font><font color="#000000" size="2">Habitualmente, los usuarios de un sistema 
  UNIX son muy abiertos con sus ficheros. Los permisos que se dan a los ficheros 
  usualmente son -rw-r--r--, lo que permite a todos los dem&aacute;s usuarios 
  leer los ficheros, pero no modificarlos de ninguna forma. Los directorios, usualmente 
  tienen los permisos -rwxr-xr-x, lo que permite que los dem&aacute;s usuarios 
  puedan moverse y ver los directorios, pero sin poder crear o borrar nuevos ficheros 
  en ellos.<br>
  </font><font color="#000000" size="2">Muchos usuarios pueden querer limitar 
  el acceso de otros usuarios a sus ficheros. Poniendo los permisos de un fichero 
  a -rw------- no se permitir&aacute; a ning&uacute;n otro usuario acceder al 
  fichero.<br>
  </font><font color="#000000" size="2">Igualmente, poniendo los permisos del 
  directorio a -rwx------ no se permitir&aacute; a los dem&aacute;s usuarios acceder 
  al directorio en cuesti&oacute;n.</font></P>
<P><font color="#000000" size="2"><u><a name="3.9.4"></a>3.9.4 Cambiando permisos<br>
  <font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.9.3">Anterior</a>- 
  <a href="#3.10">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font></u></font></u></font></u><u></u></font></u><b><u><font color="#000000" size="2"><u></u></font></u></b><u></u><u><br>
  </u></font></P>
<P><font color="#000000" size="2">El comando chmod se usa para establecer los 
  permisos de un fichero. Solo el propietario puede cambiar los permisos del fichero. 
  La sintaxis de chmod es:</font></P>
<P><font color="#000000" size="2">chmod {a,u,g,o}{+,-}{r,w,x} &lt;filenames&gt;</font></P>
<P><font color="#000000" size="2">Brevemente, indicamos a que usuarios afecta 
  all, user, group o other. Entonces se especifica sise est&aacute;n a&ntilde;adiendo 
  permisos (+) o quit&aacute;ndolos (-). Finalmente se especifica que tipo de 
  permiso read, write o execute. Algunos ejemplos:</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">chmod a+r stuff</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Da a todos los usuarios acceso al fichero.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">chmod +r stuff</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Como arriba, si no se indica a, u, g u o por 
  defecto se toma a.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">chmod og-x stuff</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Quita permisos de ejecuci&oacute;n a todos los 
  usuarios excepto al propietario.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">chmod u+rwx stuff</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Permite al propietario leer, escribir y ejecutar 
  el fichero.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">chmod o-rwx stuff</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Quita permisos de lectura, escritura y ejecuci&oacute;n 
  a todos los usuarios menos al propietario y a los usuarios del grupo del fichero.</font></P>
<P><font color="#000000" size="2"><b><u><a name="3.10"></a><font size="3">3.10 
  Manejando enlaces de ficheros<br>
  </font></u></b><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.9.4">Anterior</a>- 
  <a href="#3.10.1">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"><br>
  </font></u></b></font></P>
<P><font color="#000000" size="2">Los enlaces le permiten dar a un &uacute;nico 
  fichero m&uacute;ltiples nombres. Los ficheros son identificados por el sistema 
  por su n&uacute;mero de inodo, el cual es el &uacute;nico identificador del 
  fichero para el sistema de ficheros 4. Un directorio es una lista de n&uacute;meros 
  de inodo con sus correspondientes nombres de fichero. Cada nombre de fichero 
  en un directorio es un enlace a un inodo particular.</font></P>
<P><font color="#000000" size="2"><u><a name="3.10.1"></a>3.10.1 Enlaces duros 
  (Hard links)<br>
  <font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.10">Anterior</a>- 
  <a href="#3.10.2">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"></font></u></b><u><br>
  </u></font></P>
<P><font color="#000000" size="2">La orden ln es usada para crear m&uacute;ltiples 
  enlaces para un fichero. Por ejemplo, supongamos que tiene un fichero foo en 
  un directorio. Usando ls -i, veremos el n&uacute;mero de inodo para el fichero.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2"># ls -i foo<br>
      </font><font color="#000000" size="2">22192 foo<br>
      </font><font color="#000000" size="2">#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Aqu&iacute;, el fichero foo tiene el n&uacute;mero 
  de inodo 22192 en el sistema de ficheros. Podemos crear otro enlace a foo, llamado 
  bar:</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2"># ln foo bar</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Con ls -i veremos que los dos ficheros tienen 
  el mismo inodo.</font></P>
<DIR> 
  <DIR> 
    <p><font color="#000000" size="2"># ls -i foo bar<br>
      </font><font color="#000000" size="2">22192 bar 22192 foo<br>
      </font><font color="#000000" size="2">#</font></p>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Ahora, accediendo a foo o a bar accederemos 
  al mismo fichero. Si hace cambios en foo, estos cambios tambi&eacute;n ser&aacute;n 
  efectuados en bar. Para todos los efectos, foo y bar son el mismo fichero.<br>
  </font><font color="#000000" size="2">Estos enlaces son conocidos como enlaces 
  duros (hard links) porque directamente crean el enlace al inodo. N&oacute;tese 
  que solo podemos crear enlaces duros entre ficheros del mismo sistema de ficheros; 
  enlaces simb&oacute;licos (ver mas adelante) no tienen esta restricci&oacute;n.<br>
  </font><font color="#000000" size="2">Cuando 
  borra un fichero con rm, esta solamente borrando un enlace a un fichero. Si 
  usa el comando</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2"># rm foo</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">_____________________________________________</font></P>
<P><font color="#000000" size="2">4 La orden ls -i mostrar&aacute; los n&uacute;meros 
  de inodo.</font></P>
<P><font color="#000000" size="2">solo el enlace de nombre foo es borrado; bar 
  todav&iacute;a existir&aacute;. Un fichero es solo definitivamente borrado del 
  sistema cuando no quedan enlaces a &eacute;l. Usualmente, los ficheros tienen 
  un &uacute;nico enlace, por lo que el uso de rm los borra. Pero si el fichero 
  tiene m&uacute;ltiples enlaces, el uso de rm solo borrara un &uacute;nico enlace; 
  para borrar el fichero, deber&aacute; borrar todos los enlaces del fichero.<br>
  </font><font color="#000000" size="2">La 
  orden ls -l muestra el n&uacute;mero de enlaces a un fichero (entre otra informaci&oacute;n).</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2"># ls -l foo bar<br>
      </font><font color="#000000" size="2">-rw-r--r-- 2 root root 12 Aug 5 16:51 
      bar<br>
      </font><font color="#000000" size="2">-rw-r--r-- 2 root root 12 Aug 5 16:50 
      foo<br>
      </font><font color="#000000" size="2">#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">La segunda columna en el listado, "2", especifica 
  el n&uacute;mero de enlaces al fichero. As&iacute; resulta que un directorio 
  no es mas que un fichero que contiene informaci&oacute;n sobre la translaci&oacute;n 
  enlace a inodo. Tambi&eacute;n, cada directorio tiene al menos dos enlaces duros 
  en el: "." (un enlace apuntando a si mismo) y ".." (un enlace apuntando al directorio 
  padre). En el directorio ra&iacute;z (/), el enlace ".." simplemente apunta 
  a /.</font></P>
<P><font color="#000000" size="2"><u><a name="3.10.2"></a>3.10.2 Enlaces simb&oacute;licos<br>
  <font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.10.1">Anterior</a>- 
  <a href="#3.11">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"></font></u></b><u></u><u><br>
  </u></font></P>
<P><font color="#000000" size="2">Los enlaces simb&oacute;licos son otro tipo 
  de enlace, que es diferente al enlace duro. Un enlace simb&oacute;lico permite 
  dar a un fichero el nombre de otro, pero no enlaza el fichero con un inodo.<br>
  </font><font color="#000000" size="2">La 
  orden ln -s crea un enlace simb&oacute;lico a un fichero. Por ejemplo, si usamos 
  la orden</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2"># ln -s foo bar</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">crearemos un enlace simb&oacute;lico bar apuntando 
  al fichero foo. Si usamos ls -i, veremos que los dos ficheros tienen inodos 
  diferentes, en efecto.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2"># ls -i foo bar<br>
      </font><font color="#000000" size="2">22195 bar 22192 foo<br>
      </font><font color="#000000" size="2">#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">De cualquier modo, usando ls -l vemos que el 
  fichero bar es un enlace simb&oacute;lico apuntando a foo.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2"># ls -l foo bar<br>
      </font><font color="#000000" size="2">lrwxrwxrwx 1 root root 3 Aug 5 16:51 
      bar -&gt; foo<br>
      </font><font color="#000000" size="2">-rw-r--r-- 1 root root 12 Aug 5 16:50 
      foo<br>
      </font><font color="#000000" size="2">#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Los bits de permisos en un enlace simb&oacute;lico 
  no se usan (siempre aparecen como rwxrwxrwx). En su lugar, los permisos del 
  enlace simb&oacute;lico son determinados por los permisos del fichero "apuntado" 
  por el enlace (en nuestro ejemplo, el fichero foo).<br>
  </font><font color="#000000" size="2">Funcionalmente, los enlaces duros y simb&oacute;licos 
  son similares, pero hay algunas diferencias. Por una parte, puede crear un enlace 
  simb&oacute;lico a un fichero que no existe; lo mismo no es cierto para enlaces 
  duros. Los enlaces simb&oacute;licos son procesados por el n&uacute;cleo de 
  forma diferente a los duros, lo cual es solo una diferencia t&eacute;cnica, 
  pero a veces importante. Los enlaces simb&oacute;licos son de ayuda puesto que 
  identifican al fichero al que apuntan; con enlaces duros no hay forma f&aacute;cil 
  de saber que fichero esta enlazado al mismo inodo.<br>
  </font><font color="#000000" size="2">Los enlaces se usan en muchas partes del 
  sistema Linux. Los enlaces simb&oacute;licos son especialmente importantes para 
  las im&aacute;genes de las librer&iacute;as compartidas en /lib. Ver la Secci&oacute;n 
  4.7.2 para mas informaci&oacute;n.</font></P>
<P><font color="#000000" size="2"><b><u><a name="3.11"></a><font size="3">3.11 
  Control de Tareas<br>
  </font></u></b><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.10.2">Anterior</a>- 
  <a href="#3.11.1">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u><u></u></font></u><b><u><font color="#000000" size="2"><u><br>
  </u></font><font size="3"><br>
  </font></u></b></font></P>
<P><font color="#000000" size="2"><u><a name="3.11.1"></a>3.11.1 Tareas y procesos<br>
  <font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.11">Anterior</a>- 
  <a href="#3.11.2">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u><u></u></font></u><b><u><font color="#000000" size="2"><u><br>
  </u></font><font size="3"></font></u></b><u><br>
  </u></font></P>
<P><font color="#000000" size="2">Control de Tareas es una utilidad incluida en 
  muchos shells (incluidas Bash y Tcsh), que permite el control de multitud de 
  comandos o tareas al momento. Antes de seguir, deberemos hablar un poco sobre 
  los procesos.<br>
  </font><font color="#000000" size="2">Cada vez que usted ejecuta 
  un programa, usted lanza lo que se conoce como proceso, que es simplemente el 
  nombre que se le da a un programa cuando se esta ejecutando. El comando ps visualiza 
  la lista de procesos que se est&aacute;n ejecutando actualmente, por ejemplo:</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# ps<br>
      </font><font color="#000000" size="2">PID TT STAT TIME COMMAND<br>
      </font><font color="#000000" size="2">24 3 S 0:03 (bash)<br>
      </font><font color="#000000" size="2">161 3 R 0:00 ps<br>
      </font><font color="#000000" size="2">/home/larry#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">La columna PID representa el identificador de 
  proceso. La &uacute;ltima columna COMMAND, es el nombre del proceso que se esta 
  ejecutando. Ahora solo estamos viendo los procesos que esta ejecutando Larry5. 
  Vemos que hay dos procesos, bash (Que es el shell o int&eacute;rprete de comandos 
  que usa Larry), y el propio comando ps. Como puede observar, la bash se ejecuta 
  concurrentemente con el comando ps. La bash ejecuto ps cuando Larry tecleo el 
  comando. Cuando ps termina de ejecutarse (despu&eacute;s de mostrar la tabla 
  de procesos), el control retorna al proceso bash, que muestra el prompt, indicando 
  que esta listo para recibir otro comando.<br>
  </font><font color="#000000" size="2">Un 
  proceso que esta corriendo se denomina tarea para el shell. Los t&eacute;rminos 
  proceso y tarea, son intercambiables. Sin embargo, se suele denominar "tarea" 
  a un proceso, cuando es usado en conjunci&oacute;n con control de tareas, que 
  es un rasgo del shell que permite cambiar entre distintas tareas.</font></P>
<P><font color="#000000" size="2">_____________________________________________</font></P>
<P><font color="#000000" size="2">5 Hay muchos mas procesos aparte de estos corriendo 
  en el sistema, para verlos todos, teclearemos el comando "ps -aux".</font></P>
<P><font color="#000000" size="2">En muchos casos, los usuarios solo ejecutan 
  un trabajo cada vez, que es el &uacute;ltimo comando que ellos teclearon desde 
  el shell. Sin embargo, usando el control de tareas, usted podr&aacute; ejecutar 
  diferentes tareas al mismo tiempo, cambiando entre cada uno de ellos conforme 
  lo necesite. ¿ Cuan beneficioso puede llegar a ser esto?. Supongamos que esta 
  usted con su procesador de textos, y de repente necesita parar y realizar otra 
  tarea, con el control de tareas, usted podr&aacute; suspender temporalmente 
  el editor, y volver al shell para realizar cualquier otra tarea, y luego regresar 
  al editor como si no lo hubiese dejado nunca. Lo siguiente solo es un ejemplo, 
  hay montones de usos pr&aacute;cticos del control de tareas.</font></P>
<P><font color="#000000" size="2"><u><a name="3.11.2"></a>3.11.2 Primer plano 
  y Segundo plano<br>
  <font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.11.1">Anterior</a>- 
  <a href="#3.11.3">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u><u></u></font></u><b><u><font color="#000000" size="2"><u></u></font></u></b><u><br>
  </u></font></P>
<P><font color="#000000" size="2">Un proceso puede estar en Primer plano o en 
  Segundo plano. Solo puede haber un proceso en primer plano al mismo tiempo, 
  el proceso que esta en primer plano, es el que interact&uacute;a con usted recibe 
  entradas de teclado, y env&iacute;a las salidas al monitor. (Salvo, por supuesto, 
  que haya redirigido la entrada o la salida, como se describe en la Secci&oacute;n 
  3.8). El proceso en segundo plano, no recibe ninguna se&ntilde;al desde el teclado, 
  por lo general, se ejecutan en silencio sin necesidad de interacci&oacute;n.<br>
  </font><font color="#000000" size="2">Algunos programas necesitan mucho tiempo 
  para terminar, y no hacen nada interesante mientras tanto. Compilar programas 
  es una de estas tareas, as&iacute; como comprimir un fichero grande. No tiene 
  sentido que se siente y se aburra mientras estos procesos terminan. En estos 
  casos es mejor lanzarlos en segundo plano, para dejar el ordenador en condiciones 
  de ejecutar otro programa.<br>
  </font><font color="#000000" size="2">Los procesos pueden ser suspendidos. Un 
  proceso suspendido es aquel que no se esta ejecutando actualmente, sino que 
  esta temporalmente parado. Despu&eacute;s de suspender una tarea, puede indicar 
  a la misma que contin&uacute;e, en primer plano o en segundo, seg&uacute;n necesite. 
  Retomar una tarea suspendida no cambia en nada el estado de la misma, la tarea 
  continuara ejecut&aacute;ndose justo donde se dejo.<br>
  </font><font color="#000000" size="2">Tenga en cuenta que suspender un trabajo 
  no es lo mismo que interrumpirlo. Cuando usted interrumpe un proceso (generalmente 
  con la pulsaci&oacute;n de |_ctrl-C_|), el proceso muere, y deja de estar en 
  memoria y utilizar recursos del ordenador. Una vez eliminado, el proceso no 
  puede continuar ejecut&aacute;ndose, y deber&aacute; ser lanzado otra vez para 
  volver a realizar sus tareas. Tambi&eacute;n se puede dar el caso de que algunos 
  programas capturan la interrupci&oacute;n, de modo que pulsando |_ctrl-C_| no 
  se para inmediatamente. Esto se hace para permitir al programa realizar operaciones 
  necesarias de limpieza antes de terminar7. De hecho, algunos programas simplemente 
  no se dejan matar por ninguna interrupci&oacute;n.</font></P>
<P><font color="#000000" size="2"><u><a name="3.11.3"></a>3.11.3 Env&iacute;o 
  a segundo plano y eliminaci&oacute;n de procesos<br>
  <font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.11.2">Anterior</a>- 
  <a href="#3.12">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u><u></u></font></u><b><u><font color="#000000" size="2"><u></u></font></u></b><u><br>
  </u></font></P>
<P><font color="#000000" size="2">Empecemos con un ejemplo sencillo. El comando 
  yes es un comando aparentemente in&uacute;til que env&iacute;a una serie interminable 
  de y-es a la salida est&aacute;ndar. (Realmente es muy &uacute;til. Si se utiliza 
  una tuber&iacute;a (o "pipe") para unir la salida de yes con otro comando que 
  haga preguntas del tipo si/no, la serie de y-es confirmara todas las preguntas.)<br>
  </font><font color="#000000" size="2">Pruebe 
  con esto.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# yes<br>
      </font><font color="#000000" size="2">y<br>
      </font><font color="#000000" size="2">y<br>
      </font><font color="#000000" size="2">y<br>
      </font><font color="#000000" size="2">y<br>
      </font><font color="#000000" size="2">y</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">_____________________________________________</font></P>
<P><font color="#000000" size="2">6 La tecla de interrupci&oacute;n puede definirse 
  usando el comando stty. Por defecto, en la mayor&iacute;a de sistemas es |_ctrl-C_|, 
  pero no se puede garantizar que sea la misma en su sistema.</font></P>
<P><font color="#000000" size="2">7 Tiempo necesario para guardar algunos registros, 
  etc.</font></P>
<P><font color="#000000" size="2">La serie de y-es continuara hasta el infinito, 
  a no ser que usted la elimine, pulsando la tecla de interrupci&oacute;n, generalmente 
  |_ctrl-C_|. Tambi&eacute;n puede deshacerse de esta serie de y-es redigiriendo 
  la salida est&aacute;ndar de yes hacia /dev/null, que como recordara es una 
  especie de "agujero negro" o papelera para los datos. Todo lo que usted env&iacute;e 
  all&iacute;, desaparecer&aacute;.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# yes &gt; /dev/null</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Ahora va mucho mejor, el terminal no se ensucia, 
  pero el prompt de la shell no retorna. Esto es porque yes sigue ejecut&aacute;ndose 
  y enviando esos in&uacute;tiles y-es a /dev/null. Para recuperarlo, pulse la 
  tecla de interrupci&oacute;n.<br>
  </font><font color="#000000" size="2">Supongamos ahora que queremos dejar que 
  el comando yes siga ejecut&aacute;ndose, y volver al mismo tiempo a la shell 
  para trabajar en otras cosas. Para ello nos enviaremos a yes a segundo plano, 
  lo que nos permitir&aacute; ejecutarlo, pero sin necesidad de interacci&oacute;n.<br>
  </font><font color="#000000" size="2">Una 
  forma de mandar procesos a segundo plano es a&ntilde;adiendo un car&aacute;cter 
  "&amp;" al final de cada comando.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# yes &gt; /dev/null &amp;<br>
      </font><font color="#000000" size="2">[1] 164<br>
      </font><font color="#000000" size="2">/home/larry#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Como podr&aacute; ver, ha regresado a la shell. 
  &gt;Pero que es eso de "[1] 164"?, &gt;se esta ejecutando realmente el comando 
  yes?<br>
  </font><font color="#000000" size="2">"[1]" representa el n&uacute;mero de tarea 
  del proceso yes. La shell asigna un n&uacute;mero a cada tarea que se este ejecutando. 
  Como yes es el &uacute;nico comando que se esta ejecutando, se le asigna el 
  n&uacute;mero de tarea 1. El n&uacute;mero "164" es el n&uacute;mero de identificaci&oacute;n 
  del proceso, o PID, que es el n&uacute;mero que el sistema le asigna al proceso. 
  Ambos n&uacute;meros pueden usarse para referirse a la tarea como veremos despu&eacute;s.<br>
  </font><font color="#000000" size="2">Ahora 
  usted tiene el proceso yes corriendo en segundo plano, y enviando constantemente 
  la se&ntilde;al y hacia el dispositivo /dev/null. Para chequear el estado del 
  proceso, utilice el comando interno de la shell jobs:</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# jobs<br>
      </font><font color="#000000" size="2">[1]+ Running yes &gt;/dev/null &amp;<br>
      </font><font color="#000000" size="2">/home/larry#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">¡Ah&iacute; est&aacute;!. Tambi&eacute;n puede 
  usar el comando ps, como mostramos antes, para comprobar el estado de la tarea.<br>
  </font><font color="#000000" size="2">Para 
  eliminar una tarea, utilice el comando kill. Este comando toma como argumento 
  un n&uacute;mero de tarea o un n&uacute;mero de ID de un proceso. Esta era la 
  tarea 1, as&iacute; que usando el comando &nbsp;</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# kill %1</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">matara la tarea. Cuando se identifica la tarea 
  con el n&uacute;mero de tarea, se debe preceder el n&uacute;mero con el car&aacute;cter 
  de porcentaje (`%").<br>
  </font><font color="#000000" size="2">Ahora que ya hemos 
  matado la tarea, podemos usar el comando jobs de nuevo para comprobarlo:</font></P>
<DIR> 
  <DIR> 
    <p><font color="#000000" size="2">/home/larry# jobs<br>
      </font><font color="#000000" size="2">[1]+ Terminated yes &gt;/dev/null<br>
      </font><font color="#000000" size="2">/home/larry#</font></p>
  </DIR>
</DIR>
<P><font color="#000000" size="2">La tarea esta, en efecto, muerta, y si usa el 
  comando jobs de nuevo, no mostrar&aacute; nada. Tambi&eacute;n podr&aacute; 
  matar la tarea usando el n&uacute;mero de ID de proceso (PID), el cual se muestra 
  conjuntamente con el ID de tarea cuando arranca la misma. En nuestro ejemplo 
  el ID de proceso es 164, as&iacute; que el comando &nbsp;</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# kill 164</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">es equivalente a</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# kill %1</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">No es necesario usar el "%" cuando nos referimos 
  a una tarea a trav&eacute;s de su ID de proceso. 3.11.4 Parada y relanzamiento 
  de tareas. Hay otra manera de poner una tarea en segundo plano. Usted puede 
  lanzarlo como un proceso normal (en primer plano), pararlo, y despu&eacute;s 
  relanzarlo en segundo plano. Primero, lance el proceso yes en primer plano como 
  lo har&iacute;a normalmente:</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# yes &gt; /dev/null</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">De nuevo, dado que yes corre en primer plano, 
  no debe retornar el prompt de la shell.<br>
  </font><font color="#000000" size="2">Ahora, 
  en vez de interrumpir la tarea con |_ctrl-C_|, suspenderemos la tarea. El suspender 
  una tarea no la mata: solamente la detiene temporalmente hasta que Ud. la retoma. 
  Para hacer esto usted debe pulsar la tecla de suspender, que suele ser |_ctrl-Z_|.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# yes &gt; /dev/null<br>
      </font><font color="#000000" size="2">|_ctrl-Z_|<br>
      </font><font color="#000000" size="2">[1]+ Stopped yes &gt;/dev/null<br>
      </font><font color="#000000" size="2">/home/larry#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Mientras el proceso esta suspendido, simplemente 
  no se esta ejecutando. No gasta tiempo de CPU en la tarea. Sin embargo, usted 
  puede retomar el proceso de nuevo como si nada hubiera pasado. Continuara ejecut&aacute;ndose 
  donde se dejo.<br>
  </font><font color="#000000" size="2">Para relanzar la tarea en 
  primer plano, use el comando fg (del ingles "foreground").</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# fg<br>
      </font><font color="#000000" size="2">yes 
      &gt;/dev/null</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">La shell muestra el nombre del comando de nuevo, 
  de forma que tenga conocimiento de que tarea es la que ha puesto en primer plano. 
  Pare la tarea de nuevo, con |_ctrl-Z_|. Esta vez utilice el comando bg para 
  poner la tarea en segundo plano. Esto har&aacute; que el comando siga ejecut&aacute;ndose 
  igual que si lo hubiese hecho desde el principio con "&amp;" como en la secci&oacute;n 
  anterior.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# bg<br>
      </font><font color="#000000" size="2">[1]+ yes &gt;/dev/null &amp;<br>
      </font><font color="#000000" size="2">/home/larry#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Y tenemos de nuevo el prompt. El comando jobs 
  deber&iacute;a decirnos que yes se esta ejecutando, y podemos matar la tarea 
  con kill tal y como lo hicimos antes.<br>
  </font><font color="#000000" size="2">¿C&oacute;mo podemos parar la tarea de 
  nuevo? Si pulsa |_ctrl-Z_| no funcionara, ya que el proceso esta en segundo 
  plano. La respuesta es poner el proceso en primer plano de nuevo, con el comando 
  fg, y entonces pararlo. Como puede observar podr&aacute; usar fg tanto con tareas 
  detenidas, como con las que est&eacute;n segundo plano.<br>
  </font><font color="#000000" size="2">Hay 
  una gran diferencia entre una tarea que se encuentra en segundo plano, y una 
  que se encuentra detenida. Una tarea detenida es una tarea que no se esta ejecutando, 
  es decir, que no usa tiempo de CPU, y que no esta haciendo ning&uacute;n trabajo 
  (la tarea aun ocupa un lugar en memoria, aunque puede ser volcada a disco). 
  Una tarea en segundo plano, se esta ejecutando, y usando memoria, a la vez que 
  completando alguna acci&oacute;n mientras usted hace otro trabajo. Sin embargo, 
  una tarea en segundo plano puede intentar mostrar texto en su terminal, lo que 
  puede resultar molesto si esta intentando hacer otra cosa. Por ejemplo, si usted 
  uso el comando &nbsp;</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# yes &amp;</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">sin redirigir stdout a /dev/null, una cadena 
  de y-es se mostraran en su monitor, sin modo alguno de interrumpirlo (no puede 
  hacer uso de |_ctrl-C_| para interrumpir tareas en segundo plano). Para poder 
  parar esas interminables y-es, tendr&iacute;a que usar el comando fg para pasar 
  la tarea a primer plano, y entonces usar |_ctrl-C_| para matarla.<br>
  </font><font color="#000000" size="2">Otra 
  observaci&oacute;n. Normalmente, los comandos "fg" y "bg" act&uacute;an sobre 
  el &uacute;ltimo proceso parado (indicado por un "+" junto al n&uacute;mero 
  de tarea cuando usa el comando jobs). Si usted tiene varios procesos corriendo 
  a la vez, podr&aacute; mandar a primer o segundo plano una tarea especifica 
  indicando el ID de tarea como argumento de fg o bg, como en</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# fg %2</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">(para la tarea de primer plano n&uacute;mero 
  2), o</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# bg %3</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">(para la tarea de segundo plano n&uacute;mero 
  3). No se pueden usar los ID de proceso con fg o bg.<br>
  </font><font color="#000000" size="2">Adem&aacute;s 
  de esto, si usa el n&uacute;mero de tarea por si solo, como</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# %2</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">es equivalente a</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# fg %2</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Solo recordarle que el uso de control de tareas 
  es una utilidad de la shell. Los comandos fg, bg y jobs son internos de la shell. 
  Si por alg&uacute;n motivo usted utiliza una shell que no soporta control de 
  tareas, no espere disponer de estos comandos.<br>
  </font><font color="#000000" size="2">Y adem&aacute;s, hay algunos aspectos 
  del control de tareas que difieren entre Bash y Tcsh. De hecho, algunas shells 
  no proporcionan ning&uacute;n control de tareas, sin embargo, la mayor&iacute;a 
  de las shells disponibles para Linux soportan control de tareas.</font></P>
<P><font color="#000000" size="2"><b><u><a name="3.12"></a><font size="3">3.12 
  Usando el editor vi<br>
  </font></u></b><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.11.3">Anterior</a>- 
  <a href="#3.12.1">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"><br>
  </font></u></b></font></P>
<P><font color="#000000" size="2">Un editor de texto es simplemente un programa 
  usado para la edici&oacute;n de ficheros que contienen texto, como una carta, 
  un programa en C, o un fichero de configuraci&oacute;n del sistema. Mientras 
  que hay muchos editores de texto disponibles en Linux, el &uacute;nico editor 
  que esta garantizado encontrar en cualquier sistema UNIX es vi_el "visual editor". 
  vi no es el editor mas f&aacute;cil de usar, ni es muy autoexplicativo. De cualquier 
  forma, como es tan com&uacute;n en el mundo UNIX y es posible que alguna vez 
  necesite usarlo, aqu&iacute; encontrara algo de documentaci&oacute;n.<br>
  </font><font color="#000000" size="2">La elecci&oacute;n de un editor es principalmente 
  una cuesti&oacute;n de gusto personal y estilo. Muchos usuarios prefieren el 
  barroco, autoexplicativo y potente Emacs un editor con mas caracter&iacute;sticas 
  que cualquier otro programa &uacute;nico en el mundo UNIX. Por ejemplo, Emacs 
  tiene integrado su propio dialecto del lenguaje de programaci&oacute;n LISP 
  y tiene muchas extensiones (una de ellas es el programa "Eliza"- como programa 
  de IA). Pero como Emacs y todos sus ficheros de soporte es relativamente grande, 
  puede que no tenga acceso a &eacute;l en muchos sistemas. vi, por otra parte, 
  es peque&ntilde;o y potente, pero mas dif&iacute;cil de usar. De cualquier modo, 
  una vez que conozca la forma de funcionamiento de vi, es muy f&aacute;cil usarlo. 
  Simplemente la curva de aprendizaje es bastante pronunciada al comienzo.<br>
  </font><font color="#000000" size="2">Esta secci&oacute;n es una introducci&oacute;n 
  coherente a vi, no discutiremos todas sus caracter&iacute;sticas, solo aquellas 
  necesarias para que sepa como comenzar. Puede dirigirse a la pagina de manual 
  de vi si esta interesado en aprender mas acerca de las caracter&iacute;sticas 
  de este editor, o puede leer el libro Learning the vi Editor de O'Reilly and 
  Associates. Vea el Ap&eacute;ndice A para informaci&oacute;n.</font></P>
<P><font color="#000000" size="2"><u><a name="3.12.1"></a>3.12.1 Conceptos<br>
  <font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.12">Anterior</a>- 
  <a href="#3.12.2">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"><br>
  </font></u></b><u><br>
  </u></font></P>
<P><font color="#000000" size="2">Mientras se usa vi, en cualquier momento estar&aacute; 
  en uno de tres posibles modos de operaci&oacute;n. Estos modos son conocidos 
  como modo &oacute;rdenes, modo inserci&oacute;n y modo &uacute;ltima l&iacute;nea.<br>
  </font><font color="#000000" size="2">Cuando inicia vi, esta en el modo &oacute;rdenes. 
  Este modo le permite usar ciertas &oacute;rdenes para editar ficheros o cambiar 
  a otros modos. Por ejemplo, tecleando "x" mientras esta en el modo &oacute;rdenes, 
  borra el car&aacute;cter que hay debajo del cursor. Las teclas del cursor mueven 
  este por el fichero que estamos editando. Generalmente, las &oacute;rdenes usadas 
  en este modo son solo de uno o dos caracteres de longitud.<br>
  </font><font color="#000000" size="2">Habitualmente insertara o editara texto 
  desde el modo inserci&oacute;n. Usando vi, probablemente dedicara la mayor parte 
  del tiempo en este modo. Inicia el modo de inserci&oacute;n al usar una orden 
  como "i" (para "insertar") desde el modo de &oacute;rdenes. Una vez en el modo 
  de inserci&oacute;n, ira insertando texto en el documento desde la posici&oacute;n 
  actual del cursor. Para salir del modo de inserci&oacute;n y volver al de &oacute;rdenes, 
  pulse |_esc_|.<br>
  </font><font color="#000000" size="2">Modo &uacute;ltima l&iacute;nea es un 
  modo especial usado para proporcionar ciertas &oacute;rdenes extendidas a vi.<br>
  </font><font color="#000000" size="2">Al usar esos comandos, aparecen en la 
  &uacute;ltima l&iacute;nea de la pantalla (de ah&iacute; el nombre). Por ejemplo, 
  cuando teclea ":" desde el modo de &oacute;rdenes, entrara en el modo &uacute;ltima 
  l&iacute;nea, y podr&aacute; usar &oacute;rdenes como "wq" (para escribir el 
  fichero a disco y salir de vi), o "q!" (para salir de vi sin guardar los cambios). 
  El modo de &uacute;ltima l&iacute;nea es habitualmente usado por &oacute;rdenes 
  vi mayores de un car&aacute;cter.<br>
  </font><font color="#000000" size="2">En el modo de &uacute;ltima l&iacute;nea, 
  introduce una orden de una sola l&iacute;nea y pulsa |_enter_| para ejecutarla.</font></P>
<P><font color="#000000" size="2"><u><a name="3.12.2"></a>3.12.2 Comenzando con 
  vi<br>
  <font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.12.1">Anterior</a>- 
  <a href="#3.12.3">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"><br>
  </font></u></b><u><br>
  </u></font></P>
<P><font color="#000000" size="2">La mejor forma de entender estos conceptos es 
  arrancar vi y editar un fichero. En el ejemplo "screens" que veremos, vamos 
  a mostrar solo unas pocas l&iacute;neas de texto, como si la pantalla tuviese 
  solo seis l&iacute;neas de altura (en lugar de veinticuatro).<br>
  </font><font color="#000000" size="2">La 
  sintaxis de vi es &nbsp;</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">vi &lt;filename&gt;</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">donde &lt;filename&gt; es el nombre del fichero 
  que desea editar.<br>
  </font><font color="#000000" size="2">Arranque vi tecleando</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# vi test</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">lo que editara el fichero test. Deber&iacute;a 
  ver algo como</font></P>
<TABLE BORDER CELLSPACING=1 CELLPADDING=4 WIDTH=733>
  <TR> 
    <TD VALIGN="TOP" HEIGHT=29> 
      <P><font size="2" color="#000000">~_</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P>&nbsp;</P>
      <P><font color="#000000" size="2">~</font></P>
      <P>&nbsp;</P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P>&nbsp;</P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">"test" [New_file] </font> 
    </TD>
  </TR>
</TABLE>
<P><font color="#000000" size="2">La columna de caracteres "~" indica que esta 
  al final del fichero.</font></P>
<P><font color="#000000" size="2"><u><a name="3.12.3"></a>3.12.3 Insertando texto<br>
  <font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.12.2">Anterior</a>- 
  <a href="#3.12.4">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"></font></u></b><u><br>
  </u></font></P>
<P><font color="#000000" size="2">Esta ahora en modo &oacute;rdenes; para poder 
  insertar texto en el fichero, pulse |_i_|(lo que le har&aacute; entrar en modo 
  inserci&oacute;n), y comience a escribir.</font></P>
<TABLE BORDER CELLSPACING=1 CELLPADDING=4 WIDTH=728>
  <TR> 
    <TD VALIGN="TOP" HEIGHT=38> 
      <P><font size="2" color="#000000">Now is the time for all good men to come 
        to the aid of the party._</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P>&nbsp;</P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">~ </font> 
    </TD>
  </TR>
</TABLE>
<P><font color="#000000" size="2">Mientras inserta texto, puede escribir tantas 
  l&iacute;neas como desee (pulsando |_return_| despu&eacute;s de cada una, por 
  supuesto), y puede corregir los errores con la tecla de borrado de car&aacute;cter.<br>
  </font><font color="#000000" size="2">Para salir del modo de inserci&oacute;n 
  y volver al modo de &oacute;rdenes, pulse |_esc_|.<br>
  </font><font color="#000000" size="2">Mientras este en modo &oacute;rdenes, 
  puede usar las teclas del cursor para moverse por el fichero. En nuestro ejemplo, 
  como solo tenemos una l&iacute;nea, el tratar de usar las teclas de l&iacute;nea 
  arriba o abajo, probablemente har&aacute; que vi emita un pitido.<br>
  </font><font color="#000000" size="2">Hay 
  muchas formas de insertar texto a parte de la orden i. Por ejemplo, la orden 
  a inserta texto comenzando detr&aacute;s de la posici&oacute;n actual del cursor, 
  en lugar de la posici&oacute;n actual del cursor. Por ejemplo, use la tecla 
  de cursor a la izquierda para desplazar el cursor entre las palabras "good" 
  y "men".</font></P>
<TABLE BORDER CELLSPACING=1 CELLPADDING=4 WIDTH=728>
  <TR> 
    <TD VALIGN="TOP" HEIGHT=38> 
      <P><font size="2" color="#000000">Now is the time for all good _men to come 
        to the aid of the party.</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P>&nbsp;</P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">~ </font> 
    </TD>
  </TR>
</TABLE>
<P><font color="#000000" size="2">Pulse |_a_| para iniciar el modo inserci&oacute;n, 
  teclee "wo" y pulse |_esc_| para volver al modo de &oacute;rdenes.</font></P>
<TABLE BORDER CELLSPACING=1 CELLPADDING=4 WIDTH=728>
  <TR> 
    <TD VALIGN="TOP" HEIGHT=38> 
      <P><font size="2" color="#000000">Now is the time for all good women to 
        come to the aid of the party._</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P>&nbsp;</P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">~ </font> 
    </TD>
  </TR>
</TABLE>
<P><font color="#000000" size="2">Para comenzar a insertar texto en la l&iacute;nea 
  de debajo de la actual, use la orden "o". Por ejemplo, pulse |_o_| y teclee 
  otra l&iacute;nea o dos:</font></P>
<TABLE BORDER CELLSPACING=1 CELLPADDING=4 WIDTH=728>
  <TR> 
    <TD VALIGN="TOP" HEIGHT=38> 
      <P><font size="2" color="#000000">Now is the time for all good women to 
        come to the aid of the party.</font></P>
      <P><font color="#000000" size="2">Afterwards, we'll go out for pizza and 
        beer._</font></P>
      <P>&nbsp;</P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P>&nbsp;</P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">~ </font> 
    </TD>
  </TR>
</TABLE>
<P><font color="#000000" size="2">Solo recuerde que en cualquier momento esta 
  en modo de &oacute;rdenes (donde &oacute;rdenes como i, a o o son validas, o 
  en modo de inserci&oacute;n (cuando este insertando texto, pulse |_esc_| para 
  volver al modo de &oacute;rdenes), o en modo de &uacute;ltima l&iacute;nea (donde 
  puede introducir comandos extendidos, como veremos mas adelante).</font></P>
<P><font color="#000000" size="2"><u><a name="3.12.4"></a>3.12.4 Borrando texto<br>
  <font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.12.3">Anterior</a>- 
  <a href="#3.12.5">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"></font></u></b><u><br>
  </u></font></P>
<P><font color="#000000" size="2">Desde el modo de &oacute;rdenes, la orden x 
  borra el car&aacute;cter debajo del cursor. Si pulsa |_x_| cinco veces, terminara 
  con:</font></P>
<TABLE BORDER CELLSPACING=1 CELLPADDING=4 WIDTH=728>
  <TR> 
    <TD VALIGN="TOP" HEIGHT=38> 
      <P><font size="2" color="#000000">Now is the time for all good women to 
        come to the aid of the party.</font></P>
      <P><font color="#000000" size="2">Afterwards, we'll go out for pizza and__</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P>&nbsp;</P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">~ </font> 
    </TD>
  </TR>
</TABLE>
<P><font color="#000000" size="2">Ahora pulse |_a_|, inserte alg&uacute;n texto, 
  seguido de |_esc_|:</font></P>
<TABLE BORDER CELLSPACING=1 CELLPADDING=4 WIDTH=728>
  <TR> 
    <TD VALIGN="TOP" HEIGHT=38> 
      <P><font size="2" color="#000000">Now is the time for all good women to 
        come to the aid of the party.</font></P>
      <P><font color="#000000" size="2">Afterwards, we'll go out for pizza and 
        Diet Coke._</font></P>
      <P>&nbsp;</P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P>&nbsp;</P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">~ </font> 
    </TD>
  </TR>
</TABLE>
<P><font color="#000000" size="2">Puede borrar l&iacute;neas enteras usando la 
  orden dd (es decir, pulse |_d_| dos veces en una fila). Si el cursor esta en 
  la segunda l&iacute;nea y teclea dd,</font></P>
<TABLE BORDER CELLSPACING=1 CELLPADDING=4 WIDTH=728>
  <TR> 
    <TD VALIGN="TOP" HEIGHT=38> 
      <P><font size="2" color="#000000">Now is the time for all good women to 
        come to the aid of the party.</font></P>
      <P><font color="#000000" size="2">__</font></P>
      <P>&nbsp;</P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P>&nbsp;</P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">~ </font> 
    </TD>
  </TR>
</TABLE>
<P><font color="#000000" size="2">Para borrar la palabra sobre la que se encuentra 
  el cursor, use la orden dw. Sit&uacute;e el cursor sobre la palabra "good" y 
  pulse dw.</font></P>
<TABLE BORDER CELLSPACING=1 CELLPADDING=4 WIDTH=728>
  <TR> 
    <TD VALIGN="TOP" HEIGHT=38> 
      <P><font size="2" color="#000000">Now is the time for all good w_omen to 
        come to the aid of the party.</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P>&nbsp;</P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">~ </font> 
    </TD>
  </TR>
</TABLE>
<P>&nbsp;</P>
<P><font color="#000000" size="2"><u><a name="3.12.5"></a>3.12.5 Modificando texto<br>
  <font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.12.4">Anterior</a>- 
  <a href="#3.12.6">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"></font></u></b><u><br>
  </u></font></P>
<P><font color="#000000" size="2">Puede sustituir secciones de texto usando la 
  orden R. Situe el cursor en la primera letra de "party" y pulse |_R_|, y escriba 
  la palabra "hungry".</font></P>
<TABLE BORDER CELLSPACING=1 CELLPADDING=4 WIDTH=728>
  <TR> 
    <TD VALIGN="TOP" HEIGHT=38> 
      <P><font size="2" color="#000000">Now is the time for all good men to come 
        to the aid of the hungry._</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P>&nbsp;</P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">~ </font> 
    </TD>
  </TR>
</TABLE>
<P><font color="#000000" size="2">El uso de R para editar texto es bastante parecido 
  al uso de las &oacute;rdenes i y a, pero R sobrescribe texto en lugar de insertarlo.<br>
  </font><font color="#000000" size="2">La 
  orden r sustituye un &uacute;nico car&aacute;cter situado debajo del cursor. 
  Por ejemplo, sit&uacute;e el cursor al comienzo de la palabra "now" y escriba 
  r seguido de C. Obtendr&aacute;:</font></P>
<TABLE BORDER CELLSPACING=1 CELLPADDING=4 WIDTH=728>
  <TR> 
    <TD VALIGN="TOP" HEIGHT=38> 
      <P><font size="2" color="#000000">C_ow is the time for all good women to 
        come to the aid of the hungry.</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P>&nbsp;</P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">~ </font> 
    </TD>
  </TR>
</TABLE>
<P>&nbsp;</P>
<P><font color="#000000" size="2">La orden "~" cambia de may&uacute;sculas a min&uacute;sculas 
  o viceversa la letra sobre la que se encuentra el cursor. Por ejemplo, si sit&uacute;a 
  el cursor sobre la "o" de "Cow", y repetidamente pulsa |_~_|, obtendr&aacute;:</font></P>
<TABLE BORDER CELLSPACING=1 CELLPADDING=4 WIDTH=728>
  <TR> 
    <TD VALIGN="TOP" HEIGHT=38> 
      <P><font size="2" color="#000000">COW IS THE TIME FOR ALL GOOD WOMEN TO 
        COME TO THE AID OF THE HUNGRY</font></P>
      <P><font color="#000000" size="2">__</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P>&nbsp;</P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">~ </font> 
    </TD>
  </TR>
</TABLE>
<P>&nbsp;</P>
<P><font color="#000000" size="2"><u><a name="3.12.6"></a>3.12.6 &Oacute;rdenes 
  de movimiento<br>
  <font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.12.5">Anterior</a>- 
  <a href="#3.12.7">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"></font></u></b><u><br>
  </u></font></P>
<P><font color="#000000" size="2">Ya conoce como usar las teclas del cursor para 
  moverse por el documento. Adem&aacute;s, puede usar las &oacute;rdenes h, j, 
  k y l para mover el cursor a la izquierda, abajo, arriba y derecha respectivamente. 
  Esto es muy c&oacute;modo cuando (por alguna raz&oacute;n) sus teclas de cursor 
  no funcionen correctamente.<br>
  </font><font color="#000000" size="2">La orden w mueve el cursor al comienzo 
  de la siguiente palabra; b lo lleva al comienzo de la palabra anterior.<br>
  </font><font color="#000000" size="2">La orden 0 (cero) mueve el cursor al comienzo 
  de la l&iacute;nea actual, y la orden $ lo lleva al final de la l&iacute;nea.<br>
  </font><font color="#000000" size="2">Al editar ficheros grandes, querr&aacute; 
  moverse hacia adelante y atr&aacute;s a lo largo del fichero mostrando una pantalla 
  cada vez. Pulsando |_ctrl-F_| avanza el cursor una pantalla hacia adelante y 
  |_ctrl-B_| lo lleva una pantalla atr&aacute;s.<br>
  </font><font color="#000000" size="2">Para llevar el cursor al final del fichero, 
  pulse G. Puede tambi&eacute;n desplazarse a una l&iacute;nea arbitraria; por 
  ejemplo, pulsando la orden 10G llevara el cursor a la l&iacute;nea 10 del fichero. 
  Para desplazarse al comienzo, use 1G.<br>
  </font><font color="#000000" size="2">Puede asociar &oacute;rdenes de desplazamiento 
  con otras &oacute;rdenes como es el borrado. Por ejemplo, la orden d$ borrara 
  todo desde la posici&oacute;n del cursor al final de la l&iacute;nea; dG borrara 
  todo desde la posici&oacute;n del cursor al final del fichero.</font></P>
<P><font color="#000000" size="2"><u><a name="3.12.7"></a>3.12.7 Guardando ficheros 
  y saliendo de vi<br>
  <font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.12.6">Anterior</a>- 
  <a href="#3.12.8">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"></font></u></b><u><br>
  </u></font></P>
<P><font color="#000000" size="2">Para salir de vi sin modificar el fichero use 
  la orden :q!. Al pulsar ":", el cursor se desplazara a la &uacute;ltima l&iacute;nea 
  de la pantalla; esta en modo &uacute;ltima l&iacute;nea.</font></P>
<TABLE BORDER CELLSPACING=1 CELLPADDING=4 WIDTH=728>
  <TR> 
    <TD VALIGN="TOP" HEIGHT=38> 
      <P><font size="2" color="#000000">COW IS THE TIME FOR ALL WOMEN TO COME 
        TO THE AID OF THE HUNGRY.</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P>&nbsp;</P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">: </font> 
    </TD>
  </TR>
</TABLE>
<P><font color="#000000" size="2">En el modo de &uacute;ltima l&iacute;nea hay 
  disponibles una serie de &oacute;rdenes extendidas. Una de ellas es q!, la cual 
  permite salir de vi sin guardar los cambios. La orden :wq salva el fichero y 
  sale de vi.<br>
  </font><font color="#000000" size="2">La orden ZZ (desde el modo de &oacute;rdenes, 
  sin ":") es equivalente a :wq. Recuerde que debe pulsar |_enter_| despu&eacute;s 
  de introducir la orden para que esta se ejecute en el modo &uacute;ltima l&iacute;nea.<br>
  </font><font color="#000000" size="2">Para salvar el fichero sin salir de vi, 
  simplemente use :w.</font></P>
<P><font color="#000000" size="2"><u><a name="3.12.8"></a>3.12.8 Editando otro 
  fichero<br>
  <font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.12.7">Anterior</a>- 
  <a href="#3.12.9">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"></font></u></b><u><br>
  </u></font></P>
<P><font color="#000000" size="2">Para editar otro fichero use la orden :e. Por 
  ejemplo, para dejar de editar el fichero test y en su lugar editar el fichero 
  foo, use la orden</font></P>
<TABLE BORDER CELLSPACING=1 CELLPADDING=4 WIDTH=728>
  <TR> 
    <TD VALIGN="TOP" HEIGHT=38> 
      <P><font size="2" color="#000000">COW IS THE TIME FOR ALL WOMEN TO COME 
        TO THE AID OF THE HUNGRY.</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P>&nbsp;</P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">:e foo </font> 
    </TD>
  </TR>
</TABLE>
<P><font color="#000000" size="2">Si usa :e sin salvar primero el fichero, obtendr&aacute; 
  el mensaje de error</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">No write since last change (":edit!" overrides)</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">lo cual significa que vi no quiere editar otro 
  fichero hasta que salve el primero. En este punto, puede usar :w para guardar 
  el fichero original, y entonces usar :e, o puede usar la orden</font></P>
<TABLE BORDER CELLSPACING=1 CELLPADDING=4 WIDTH=728>
  <TR> 
    <TD VALIGN="TOP" HEIGHT=38> 
      <P><font size="2" color="#000000">COW IS THE TIME FOR ALL WOMEN TO COME 
        TO THE AID OF THE HUNGRY.</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P>&nbsp;</P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">:e! Foo </font> 
    </TD>
  </TR>
</TABLE>
<P><font color="#000000" size="2">El signo "!" le dice a vi lo que realmente desea 
  usted editar el nuevo fichero sin salvar los cambios del primero.</font></P>
<P><font color="#000000" size="2"><u><a name="3.12.9"></a>3.12.9 Incluyendo otros 
  ficheros<br>
  <font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.12.8">Anterior</a>- 
  <a href="#3.12.10">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"></font></u></b><u><br>
  </u></font></P>
<P><font color="#000000" size="2">Si usas la orden :r Puede incluir el contenido 
  de otro fichero en el fichero que esta editando. Por ejemplo</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">:r foo.txt</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">insertar&iacute;a el contenido del fichero foo.txt 
  en el texto en la posici&oacute;n actual de cursor.</font></P>
<P><font color="#000000" size="2"><U><a name="3.12.10"></a>3.12.10 Ejecutando 
  comandos del </u>int&eacute;rprete<br>
  <u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.12.9">Anterior</a>- 
  <a href="#3.12.11">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"></font></u></b><br>
  </font></P>
<P><font color="#000000" size="2">Puede tambi&eacute;n ejecutar comandos del int&eacute;rprete 
  desde el interior de vi. La orden :r! funciona como :r, pero en lugar de leer 
  un fichero, inserta la salida de un comando dado en el fichero en la posici&oacute;n 
  actual del cursor. Por ejemplo, si usa la orden</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">:r! ls -F</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">obtendr&aacute;</font></P>
<TABLE BORDER CELLSPACING=1 CELLPADDING=4 WIDTH=728>
  <TR> 
    <TD VALIGN="TOP" HEIGHT=38> 
      <P><font size="2" color="#000000">COW IS THE TIME FOR ALL WOMEN TO COME 
        TO THE AID OF THE HUNGRY.</font></P>
      <P><font color="#000000" size="2">Letters/</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P><font color="#000000" size="2">misc/</font></P>
      <P><font color="#000000" size="2">papers/</font></P>
      <P><font color="#000000" size="2">__</font></P>
      <P><font color="#000000" size="2">~</font></P>
      <P>&nbsp;</P>
      <P><font color="#000000" size="2">~ </font> 
    </TD>
  </TR>
</TABLE>
<P>&nbsp;</P>
<P><font color="#000000" size="2">Tambi&eacute;n puede salir a un int&eacute;rprete 
  de comandos desde vi, es decir, ejecutar una orden desde dentro de vi y volver 
  al editor una vez esta finalice. Por ejemplo, si usa la orden &nbsp;</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">:! ls -F</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">la orden ls -F ser&aacute; ejecutada, y los 
  resultados mostrados en la pantalla, pero no insertados en el fichero en edici&oacute;n. 
  Si usa la orden</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">:shell</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">vi iniciara una instancia del int&eacute;rprete 
  de comandos, permiti&eacute;ndole temporalmente dejar a vi "parado" mientras 
  ejecuta otras &oacute;rdenes. Simplemente salga del int&eacute;rprete de comandos 
  (usando la orden exit) para regresar a vi</font></P>
<P><font color="#000000" size="2"><u><a name="3.12.11"></a>3.12.11 Obteniendo 
  ayuda<br>
  <font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.12.10">Anterior</a>- 
  <a href="#3.13">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"></font></u></b><u><br>
  </u></font></P>
<P><font color="#000000" size="2">vi no proporciona demasiada ayuda de forma interactiva 
  (la mayor&iacute;a de los programas UNIX no lo hacen), pero siempre puede leer 
  la pagina de manual para vi. vi es un "front-end" visual para el editor ex: 
  es decir, es ex quien maneja la mayor&iacute;a de las &oacute;rdenes en el modo 
  &uacute;ltima l&iacute;nea. Luego adem&aacute;s de leer la pagina de vi, consulte 
  la de ex tambi&eacute;n.</font></P>
<P><font color="#000000" size="2"><b><u><a name="3.13"></a><font size="3">3.13 
  Personalizando su entorno<br>
  </font></u></b><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.12.11">Anterior</a>- 
  <a href="#3.13.1">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"><br>
  </font></u></b></font></P>
<P><font color="#000000" size="2">El int&eacute;rprete de comandos proporciona 
  muchos mecanismos para personalizar su entorno de trabajo. Como hemos mencionado 
  antes, el int&eacute;rprete de comandos es mas que un mero int&eacute;rprete 
  es tambi&eacute;n un poderoso lenguaje de programaci&oacute;n. Aunque escribir 
  guiones del int&eacute;rprete de comandos es una tarea extensa, nos gustar&iacute;a 
  introducirle algunas formas en las que puede simplificar su trabajo en un sistema 
  UNIX mediante el uso de caracter&iacute;sticas avanzadas del int&eacute;rprete.<br>
  </font><font color="#000000" size="2">Como mencionamos antes, diferentes interpretes 
  usan diferentes sintaxis para la ejecuci&oacute;n de guiones. Por ejemplo, Tcsh 
  usa una notaci&oacute;n al estilo C, mientras que Bourne usa otro tipo de sintaxis. 
  En esta secci&oacute;n no nos fijaremos en las diferencias entre los dos y supondremos 
  que los guiones son escritos con la sintaxis del int&eacute;rprete de comandos 
  Bourne.</font></P>
<P><font color="#000000" size="2"><u><a name="3.13.1"></a>3.13.1 Guiones del int&eacute;rprete 
  de comandos<br>
  <font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.13">Anterior</a>- 
  <a href="#3.13.2">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"></font></u></b><u><br>
  </u></font></P>
<P><font color="#000000" size="2">Supongamos que usa una serie de comandos a menudo, 
  y le gustar&iacute;a acortar el tiempo requerido para teclear agrup&aacute;ndolos 
  en una &uacute;nica "orden". Por ejemplo, las &oacute;rdenes</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# cat chapter1 chapter2 chapter3 
      &gt; book<br>
      </font><font color="#000000" size="2">/home/larry# wc -l book<br>
      </font><font color="#000000" size="2">/home/larry# 
      lp book</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">concatenaran los ficheros chapter1, chapter2 
  y chapter3 y guardara el resultado en el fichero book.<br>
  </font><font color="#000000" size="2">Entonces, se mostrar&aacute; el recuento 
  del n&uacute;mero de l&iacute;neas del fichero book y finalmente se imprimir&aacute; 
  con el comando lp.<br>
  </font><font color="#000000" size="2">En lugar de teclear 
  todos esos comandos, podr&iacute;a agruparlos en un gui&oacute;n del int&eacute;rprete 
  de comandos. Describimos los guiones brevemente en la Secci&oacute;n 3.13.1. 
  El gui&oacute;n usado para ejecutar todas las &oacute;rdenes seria</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">#!/bin/sh<br>
      </font><font color="#000000" size="2"># A shell script to create and print 
      the book</font></P>
    <P><font color="#000000" size="2">cat chapter1 chapter2 chapter3 &gt; book<br>
      </font><font color="#000000" size="2">wc -l book<br>
      </font><font color="#000000" size="2">lp 
      book</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Si el gui&oacute;n se salva en el fichero makebook, 
  podr&iacute;a simplemente usar la orden<br>
  </font><font color="#000000" size="2">/home/larry# makebook</font></P>
<P><font color="#000000" size="2">para ejecutar todas las &oacute;rdenes del gui&oacute;n. 
  Los guiones son simples ficheros de texto; puede crearlos con un editor como 
  emacs o vi 8.<br>
  </font><font color="#000000" size="2">Veamos este gui&oacute;n. La primera l&iacute;nea 
  "#!/bin/sh", identifica el fichero como un gui&oacute;n y le dice al int&eacute;rprete 
  de comandos como ejecutarlo. Instruye al int&eacute;rprete a pasarle el gui&oacute;n 
  a /bin/sh para la ejecuci&oacute;n, donde /bin/sh es el programa del int&eacute;rprete. 
  ¿Por qu&eacute; es esto importante? En la mayor&iacute;a de los sistemas UNIX 
  /bin/sh es un int&eacute;rprete de comandos Bourne, como Bash. Forzando al gui&oacute;n 
  a ejecutarse usando /bin/sh nos estamos asegurando que ser&aacute; interpretado 
  seg&uacute;n la sintaxis de Bourne. Esto har&aacute; que el gui&oacute;n se 
  ejecute usando la sintaxis Bourne aunque este usando Tcsh como int&eacute;rprete 
  de comandos.<br>
  </font><font color="#000000" size="2">La segunda l&iacute;nea es un comentario. 
  Estos comienzan con el car&aacute;cter "#" y contin&uacute;an hasta el final 
  de la l&iacute;nea. Los comentarios son ignorados por el int&eacute;rprete de 
  comandos son habitualmente usados para identificar el gui&oacute;n con el programador.<br>
  </font><font color="#000000" size="2">El resto de las l&iacute;neas del gui&oacute;n 
  son simplemente &oacute;rdenes como las que podr&iacute;a teclear directamente.<br>
  </font><font color="#000000" size="2">En 
  efecto, el int&eacute;rprete de comandos lee cada l&iacute;nea del gui&oacute;n 
  y ejecuta la l&iacute;nea como si hubiese sido tecleada en la l&iacute;nea de 
  comandos.</font></P>
<P><font color="#000000" size="2">_____________________________________________</font></P>
<P><font color="#000000" size="2">8 vi se describe en la Secci&oacute;n 3.12.</font></P>
<P><font color="#000000" size="2">Los permisos son importantes para los guiones. 
  Si crea un gui&oacute;n, debe asegurarse de que tiene permisos de ejecuci&oacute;n 
  para poder ejecutarlo9. La orden&nbsp;</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# chmod u+x makebook</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">puede ser usada para dar permisos de ejecuci&oacute;n 
  al gui&oacute;n makebook.</font></P>
<P><font color="#000000" size="2"><u><a name="3.13.2"></a>3.13.2 Variables del 
  int&eacute;rprete de comandos y el entorno<br>
  <font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.13.1">Anterior</a>- 
  <a href="#3.13.3">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"></font></u></b><u></u><u><br>
  </u></font></P>
<P><font color="#000000" size="2">El int&eacute;rprete de comandos le permite 
  definir variables como la mayor&iacute;a de los lenguajes de programaci&oacute;n. 
  Una variable es simplemente un trozo de datos al que se le da un nombre.<br>
  </font><font color="#000000" size="2">3 N&oacute;tese que Tcsh, as&iacute; como 
  otros interpretes del estilo C, usan un mecanismo diferente para inicializar 
  variables del descrito aqu&iacute;. Esta discusi&oacute;n supondr&aacute; el 
  uso del int&eacute;rprete Bourne, como es Bash (el cual probablemente esta usando). 
  Vea la pagina de manual de Tcsh para mas detalles.<br>
  </font><font color="#000000" size="2">Cuando 
  asigna un valor a una variable (usando el operador "="), puede acceder a la 
  variable a&ntilde;adiendo a su nombre "$", como se ve a continuaci&oacute;n.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# foo="hello there"</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">A la variable foo se le da el valor "hello there". 
  Podemos ahora hacer referencia a ese valor a trav&eacute;s del nombre de la 
  variable con el prefijo "$". La orden</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# echo $foo<br>
      </font><font color="#000000" size="2">hello there<br>
      </font><font color="#000000" size="2">/home/larry#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">produce el mismo resultado que</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# echo "hello there"<br>
      </font><font color="#000000" size="2">hello there<br>
      </font><font color="#000000" size="2">/home/larry#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Estas variables son internas al int&eacute;rprete. 
  Esto significa que solo este podr&aacute; acceder a las variables.<br>
  </font><font color="#000000" size="2">Esto puede ser &uacute;til en los guiones; 
  si necesita mantener, por ejemplo, el nombre de un fichero, puede almacenarlo 
  en una variable. Usando la orden set mostrar&aacute; una lista de todas las 
  variables definidas en el int&eacute;rprete de comandos.<br>
  </font><font color="#000000" size="2">De cualquier modo, el int&eacute;rprete 
  de comandos permite exportar variables al entorno. El entorno es el conjunto 
  de variables a las cuales tienen acceso todas las &oacute;rdenes que ejecute. 
  Una vez que se define una variable en el int&eacute;rprete, exportarla hace 
  que se convierta tambi&eacute;n en parte del entorno. La orden export es usada 
  para exportar variables al entorno.<br>
  </font><font color="#000000" size="2">3 De 
  nuevo, hemos de diferenciar entre Bash y Tcsh. Si esta usando Tcsh, deber&aacute; 
  usar una sintaxis diferente para las variables de entorno (se usa la orden setenv). 
  Dir&iacute;jase a la pagina de manual de Tcsh para mas informaci&oacute;n.</font></P>
<P><font color="#000000" size="2">_____________________________________________</font></P>
<P><font color="#000000" size="2">9 Cuando crea ficheros de texto, los permisos 
  por defecto usualmente no incluyen los de ejecuci&oacute;n.</font></P>
<P><font color="#000000" size="2">El entorno es muy importante en un sistema UNIX. 
  Le permite configurar ciertas &oacute;rdenes simplemente inicializando variables 
  con las &oacute;rdenes ya conocidas.<br>
  </font><font color="#000000" size="2">Veamos un ejemplo r&aacute;pido. La variable 
  de entorno PAGER es usada por la orden man. Especifica la orden que se usara 
  para mostrar las paginas del manual una a una. Si inicializa PAGER con el nombre 
  del programa, se usara este para mostrar las paginas de manual en lugar de more 
  (el cual es usado por defecto).<br>
  </font><font color="#000000" size="2">Inicialice 
  PAGER a "cat". Esto har&aacute; que la salida de man sea mostrada de una, sin 
  pausas entre paginas.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# PAGER="cat"</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Ahora exportamos PAGER al entorno.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# export PAGER</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Pruebe la orden man ls. La pagina deber&iacute;a 
  volar por su pantalla sin detenerse entre paginas. Ahora, si inicializa PAGER 
  a "more", se usara la orden more para mostrar las paginas del manual.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# PAGER="more"</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">N&oacute;tese que no hemos de usar la orden 
  export despu&eacute;s del cambio de la variable PAGER. Solo hemos de exportar 
  las variables una vez; cualquier cambio efectuado con posterioridad ser&aacute; 
  autom&aacute;ticamente propagado al entorno.<br>
  </font><font color="#000000" size="2">Las paginas de manual para una orden en 
  particular, le informaran acerca del uso de alguna variable de entorno por parte 
  de esa orden; por ejemplo, la pagina de manual de man explica que PAGER es usado 
  para especificar la orden de paginado.<br>
  </font><font color="#000000" size="2">Algunas &oacute;rdenes comparten variables 
  de entorno; por ejemplo, muchas &oacute;rdenes usan la variable EDITOR para 
  especificar el editor por defecto para usar si es necesario.<br>
  </font><font color="#000000" size="2">El entorno es tambi&eacute;n usado para 
  guardar informaci&oacute;n importante acerca de la sesi&oacute;n en curso.<br>
  </font><font color="#000000" size="2">Un 
  ejemplo es la variable de entorno HOME, que contiene el nombre del directorio 
  de origen del usuario.</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry/papers# echo $HOME<br>
      </font><font color="#000000" size="2">/home/larry</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Otra variable de entorno interesante es PS1, 
  la cual define el "prompt" principal que usara el int&eacute;rprete. Por ejemplo,</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# PS1="Your command, please: 
      "<br>
      </font><font color="#000000" size="2">Your command, please:</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Para volver a inicializar el "prompt" a su valor 
  habitual (el cual contiene el directorio actual seguido por el s&iacute;mbolo 
  "#"),<br>
  </font><font color="#000000" size="2">Your command, please: PS1="\w# "</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry#</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">La pagina de manual de bash describe la sintaxis 
  usada para inicializar el "prompt".</font></P>
<P><font color="#000000" size="2"><i>3.13.2.1 La variable de entorno PATH</i></font></P>
<P><font color="#000000" size="2">Cuando usa la orden ls &gt;como encuentra el 
  int&eacute;rprete el programa ejecutable ls?. De hecho, ls se encuentra en /bin/ls 
  en la mayor&iacute;a de los sistemas. El int&eacute;rprete usa la variable de 
  entorno PATH para localizar los ficheros ejecutables u &oacute;rdenes que tecleamos.<br>
  </font><font color="#000000" size="2">Por 
  ejemplo, su variable PATH puede inicializarse a:</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/bin:/usr/bin:/usr/local/bin:.</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">Esto es una lista de directorios en los que 
  el int&eacute;rprete debe buscar. Cada directorio esta separado por un ":". 
  Cuando usa la orden ls, el int&eacute;rprete primero busca /bin/ls, luego /usr/bin/ls 
  y as&iacute; hasta que lo localice o acabe la lista.<br>
  </font><font color="#000000" size="2">N&oacute;tese 
  que PATH no interviene en la localizaci&oacute;n de ficheros regulares. Por 
  ejemplo, si usa la orden</font></P>
<DIR> 
  <DIR> 
    <P><font color="#000000" size="2">/home/larry# cp foo bar</font></P>
  </DIR>
</DIR>
<P><font color="#000000" size="2">El int&eacute;rprete no usara PATH para localizar 
  los ficheros foo y bar, esos nombres se suponen completos. Solo se usara PATH 
  para localizar el programa ejecutable cp.<br>
  </font><font color="#000000" size="2">Esto le permitir&aacute; ahorrar mucho 
  tiempo; significa que no deber&aacute; recordar donde son guardadas las &oacute;rdenes. 
  En muchos sistemas los ficheros ejecutables se dispersan por muchos sitios, 
  como /usr/bin, /bin o /usr/local/bin. En lugar de dar el nombre completo con 
  el camino (como /usr/bin/cp), solo hemos de inicializar PATH con la lista de 
  los directorios donde queremos que se busquen autom&aacute;ticamente.<br>
  </font><font color="#000000" size="2">N&oacute;tese que PATH contiene ".", el 
  cual es el directorio actual de trabajo. Esto le permite crear guiones o programas 
  y ejecutarlos desde su directorio de trabajo actual sin tener que especificarlo 
  directamente (como en ./makebool). Si un directorio no esta en su PATH, entonces 
  el int&eacute;rprete no buscara en el &oacute;rdenes para ejecutar esto incluye 
  al directorio de trabajo.</font></P>
<P><font color="#000000" size="2"><U><a name="3.13.3"></a>3.13.3 Guiones de inicializaci&oacute;n 
  del </u>int&eacute;rprete<br>
  <u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.13.2">Anterior</a>- 
  <a href="#3.14">Siguiente </a>- <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"></font></u></b><u></u><br>
  </font></P>
<P><font color="#000000" size="2">A parte de los guiones que puede crear, hay 
  un n&uacute;mero de estos que usa el int&eacute;rprete de comandos para ciertos 
  prop&oacute;sitos. Los mas importantes son sus guiones de inicializaci&oacute;n, 
  guiones autom&aacute;ticamente ejecutados por el int&eacute;rprete al abrir 
  una sesi&oacute;n.<br>
  </font><font color="#000000" size="2">Los guiones de inicializaci&oacute;n son 
  eso, simples guiones como los descritos arriba. De cualquier modo, son muy &uacute;tiles 
  para la inicializaci&oacute;n de su entorno al ejecutarse autom&aacute;ticamente. 
  Por ejemplo, si siempre usa la orden mail para comprobar si tiene correo al 
  iniciar una sesi&oacute;n, incluya en su gui&oacute;n de inicializaci&oacute;n 
  dicha orden y ser&aacute; ejecutada autom&aacute;ticamente.<br>
  </font><font color="#000000" size="2">Tanto Bash como Tcsh distinguen entre 
  un int&eacute;rprete de presentaci&oacute;n y otras invocaciones del int&eacute;rprete. 
  Un int&eacute;rprete de presentaci&oacute;n es el que se ejecuta en el momento 
  de la presentaci&oacute;n al sistema (login). Es el &uacute;nico que usara. 
  De cualquier modo, si ejecuta una opci&oacute;n de salir a un int&eacute;rprete 
  desde alg&uacute;n programa, como vi, inicializa otra instancia del int&eacute;rprete 
  de comandos, el cual no es su int&eacute;rprete de presentaci&oacute;n. Adem&aacute;s, 
  en cualquier momento que ejecuta un gui&oacute;n, autom&aacute;ticamente esta 
  arrancando otro int&eacute;rprete que va a ser el encargado de ejecutar el gui&oacute;n.<br>
  </font><font color="#000000" size="2">Los ficheros de inicializaci&oacute;n 
  usados por Bash son: /etc/profile (configurado por el administrador del sistema, 
  y ejecutado por todos los usuarios de Bash en el momento de la presentaci&oacute;n 
  al sistema), $HOME/.bash_profile (ejecutado por una sesi&oacute;n de presentaci&oacute;n 
  Bash) y $HOME/.bashrc (ejecutadas por todas las sesiones Bash que no son de 
  presentaci&oacute;n). Si .bash_profile no esta presente, se usa en su lugar 
  .profile<br>
  </font><font color="#000000" size="2">Tcsh usa los siguientes guiones de inicializaci&oacute;n: 
  /etc/csh.login (ejecutado por todos los usuarios de Tcsh en el momento de la 
  presentaci&oacute;n al sistema), $HOME/.tcshrc (ejecutado en la presentaci&oacute;n 
  al sistema por todas las instancias nuevas de Tcsh) y $HOME/.login (ejecutado 
  en la presentaci&oacute;n al sistema, seguido .tcshrc). Si .tcshrc no esta presente, 
  .cshrc se usa en su lugar.<br>
  </font><font color="#000000" size="2">Para entender completamente la funci&oacute;n 
  de estos ficheros, necesitara aprender mas acerca del int&eacute;rprete de comandos. 
  La programaci&oacute;n de guiones es una materia complicada, mas all&aacute; 
  del alcance de este libro. Lea las paginas de manual de bash y/o tcsh para aprender 
  mas sobre la configuraci&oacute;n de su entorno.</font></P>
<P><font color="#000000" size="2"><b><u><a name="3.14"></a><font size="3">3.14 
  ¿Quieres seguir por tu cuenta?<br>
  </font></u></b><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000" size="2"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000"><u><font size="2"><font color="#000000" size="2"><a href="#3.13.3">Anterior</a>- 
  Siguiente - <a href="#indice">&Iacute;ndice</a> </font></font></u></font></font></u></font></font></u></font></font></u></font></u></font></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font></u></font><font size="3"></font></u><b><u><font size="3"><br>
  </font></u></b></font></P>
<P><font color="#000000" size="2">Esperamos haberle proporcionado suficiente informaci&oacute;n 
  para darle una idea b&aacute;sica de como usar el sistema, teniendo en cuenta 
  que la mayor&iacute;a de los aspectos mas importantes e interesantes de Linux 
  no est&aacute;n cubiertos aqu&iacute;, esto es muy b&aacute;sico. Con esta base, 
  en poco tiempo estar&aacute; ejecutando complicadas aplicaciones y aprovechando 
  todo el potencial de tu sistema. Si la cosa no es muy excitante al comienzo, 
  no desespere, hay mucho que aprender.<br>
  </font><font color="#000000" size="2">Una herramienta indispensable para aprender 
  acerca del sistema son las paginas del manual. Aunque muchas de las paginas 
  pueden parecer confusas al principio, si se profundiza hay gran cantidad de 
  informaci&oacute;n en ellas.<br>
  </font><font color="#000000" size="2">Tambi&eacute;n es interesante leer un 
  libro sobre la utilizaci&oacute;n de un sistema UNIX. Hay mucho mas en UNIX 
  de lo que pueda parecer a simple vista, desafortunadamente, la mayor&iacute;a 
  de ello queda fuera del alcance de este libro. En el ap&eacute;ndice A encontraras 
  una lista de algunos buenos libros sobre UNIX.</font></P>
</BODY>
</HTML>
